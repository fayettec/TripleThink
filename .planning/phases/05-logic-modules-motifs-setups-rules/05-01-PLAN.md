---
phase: 05-logic-modules-motifs-setups-rules
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [db/modules/motif-instances.js, db/modules/setup-payoffs.js]
autonomous: true

must_haves:
  truths:
    - "Motif instances can be created and retrieved by project"
    - "Motif types are validated (visual, dialogue, situational, symbolic, musical)"
    - "Setup/payoff pairs can be created and tracked"
    - "Unfired setups can be queried (planted but not yet paid off)"
  artifacts:
    - path: "db/modules/motif-instances.js"
      provides: "Motif pattern tracking with CRUD operations"
      min_lines: 80
      exports: ["createMotifInstance", "getMotifInstancesByProject", "getMotifInstancesByType", "getMotifInstanceById", "updateMotifInstance", "deleteMotifInstance"]
    - path: "db/modules/setup-payoffs.js"
      provides: "Setup/payoff tracking with unfired query"
      min_lines: 100
      exports: ["createSetupPayoff", "getSetupPayoffsByProject", "getSetupPayoffById", "updateSetupPayoff", "deleteSetupPayoff", "getUnfiredSetups", "fireSetup"]
  key_links:
    - from: "motif-instances.js"
      to: "MOTIF_INSTANCES table"
      via: "db.prepare() and INSERT/SELECT statements"
      pattern: "db\\.prepare\\(.*motif_instances"
    - from: "setup-payoffs.js"
      to: "SETUP_PAYOFFS table"
      via: "db.prepare() and INSERT/SELECT statements"
      pattern: "db\\.prepare\\(.*setup_payoffs"
    - from: "getUnfiredSetups"
      to: "status = 'planted' OR status = 'referenced'"
      via: "WHERE clause filtering unfired statuses"
      pattern: "status.*IN.*planted.*referenced"
---

<objective>
Create motif-instances.js and setup-payoffs.js modules for pattern tracking and Chekhov's gun management.

Purpose: Complete third wave of logic layer modules, enabling recurring pattern tracking (motifs) and narrative promise tracking (setup/payoffs). These modules follow established patterns from Phases 3-4.

Output: Two database modules with full CRUD operations, specialized queries (unfired setups), and self-tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/CONVENTIONS.md

# Prior logic layer modules (established patterns):
@.planning/phases/03-logic-layer-modules-causality-arcs/03-01-SUMMARY.md
@.planning/phases/04-logic-modules-conflicts-themes/04-01-SUMMARY.md

# Schema reference:
@db/migrations/006_logic_layer.sql

# Existing modules (pattern reference):
@db/modules/story-conflicts.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create motif-instances.js module</name>
  <files>db/modules/motif-instances.js</files>
  <action>
    Create motif-instances.js following established module factory pattern:

    **Module structure:**
    - Require uuid (for UUID generation)
    - Define MOTIF_TYPES constant: ['visual', 'dialogue', 'situational', 'symbolic', 'musical']
    - Export factory function: `module.exports = (db) => { ... }`

    **Functions to implement (6 total):**

    1. `createMotifInstance({ project_id, motif_type, linked_entity_id, description, significance })`:
       - Validate motif_type against MOTIF_TYPES array
       - Generate motif_uuid with uuidv4()
       - Set created_at with Date.now()
       - INSERT into motif_instances table
       - Return created motif object

    2. `getMotifInstancesByProject(project_id)`:
       - SELECT all columns WHERE project_id = ?
       - Return array of motif objects

    3. `getMotifInstancesByType(project_id, motif_type)`:
       - Validate motif_type against MOTIF_TYPES
       - SELECT all columns WHERE project_id = ? AND motif_type = ?
       - Return array of motif objects

    4. `getMotifInstanceById(motif_uuid)`:
       - SELECT all columns WHERE motif_uuid = ?
       - Return single motif object or undefined

    5. `updateMotifInstance(motif_uuid, updates)`:
       - Whitelist allowed fields: description, significance, linked_entity_id
       - Validate motif_type if present in updates
       - Build dynamic UPDATE statement
       - Return updated motif object

    6. `deleteMotifInstance(motif_uuid)`:
       - DELETE FROM motif_instances WHERE motif_uuid = ?
       - Return { deleted: true }

    **Validation:**
    - Throw descriptive errors for invalid motif_type (include MOTIF_TYPES.join(', ') in message)
    - Validate before database interaction (fail fast)

    **Documentation:**
    - Add JSDoc comments for all exported functions
    - Include parameter types and descriptions
    - Document return types

    **Self-test:**
    - Add `if (require.main === module)` block at end
    - Create in-memory database with schema
    - Test all 6 functions
    - Include assertions for: creation, retrieval by project/type/ID, update, delete, type validation

    **Pattern references:**
    - Use db/modules/story-conflicts.js as template for structure
    - Follow same naming conventions (camelCase functions, snake_case columns)
    - Use prepared statements for all queries
  </action>
  <verify>node db/modules/motif-instances.js runs self-test without errors</verify>
  <done>motif-instances.js exports 6 functions, self-test passes with 8+ assertions</done>
</task>

<task type="auto">
  <name>Task 2: Create setup-payoffs.js module</name>
  <files>db/modules/setup-payoffs.js</files>
  <action>
    Create setup-payoffs.js following established module factory pattern:

    **Module structure:**
    - Require uuid (for UUID generation)
    - Define SETUP_STATUSES constant: ['planted', 'referenced', 'fired', 'unfired']
    - Export factory function: `module.exports = (db) => { ... }`

    **Functions to implement (7 total):**

    1. `createSetupPayoff({ project_id, setup_event_id, description, planted_chapter, status = 'planted' })`:
       - Validate status against SETUP_STATUSES array
       - Generate setup_payoff_uuid with uuidv4()
       - Set created_at with Date.now()
       - INSERT into setup_payoffs table with NULL payoff_event_id and fired_chapter
       - Return created setup_payoff object

    2. `getSetupPayoffsByProject(project_id)`:
       - SELECT all columns WHERE project_id = ?
       - Return array of setup_payoff objects

    3. `getSetupPayoffById(setup_payoff_uuid)`:
       - SELECT all columns WHERE setup_payoff_uuid = ?
       - Return single setup_payoff object or undefined

    4. `updateSetupPayoff(setup_payoff_uuid, updates)`:
       - Whitelist allowed fields: description, status, payoff_event_id, fired_chapter
       - Validate status if present in updates
       - Build dynamic UPDATE statement
       - Return updated setup_payoff object

    5. `deleteSetupPayoff(setup_payoff_uuid)`:
       - DELETE FROM setup_payoffs WHERE setup_payoff_uuid = ?
       - Return { deleted: true }

    6. `getUnfiredSetups(project_id)`:
       - SELECT all columns WHERE project_id = ? AND status IN ('planted', 'referenced')
       - Return array of setup_payoff objects with no payoff_event_id
       - This identifies Chekhov's guns that haven't fired yet

    7. `fireSetup(setup_payoff_uuid, payoff_event_id, fired_chapter)`:
       - UPDATE status = 'fired', payoff_event_id = ?, fired_chapter = ? WHERE setup_payoff_uuid = ?
       - Helper function for marking setup as fired
       - Return updated setup_payoff object

    **Validation:**
    - Throw descriptive errors for invalid status (include SETUP_STATUSES.join(', ') in message)
    - Validate before database interaction (fail fast)

    **Documentation:**
    - Add JSDoc comments for all exported functions
    - Document getUnfiredSetups as "Chekhov's gun tracker"
    - Include parameter types and descriptions
    - Document return types

    **Self-test:**
    - Add `if (require.main === module)` block at end
    - Create in-memory database with schema
    - Test all 7 functions
    - Include assertions for: creation, retrieval by project/ID, unfired query (should return planted/referenced), fireSetup helper, update, delete, status validation

    **Pattern references:**
    - Use db/modules/story-conflicts.js as template for structure
    - Follow same naming conventions (camelCase functions, snake_case columns)
    - Use prepared statements for all queries
  </action>
  <verify>node db/modules/setup-payoffs.js runs self-test without errors</verify>
  <done>setup-payoffs.js exports 7 functions including getUnfiredSetups, self-test passes with 10+ assertions</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Both modules created with correct exports
- [ ] Self-tests pass for both modules
- [ ] Motif types validated (5 types)
- [ ] Setup statuses validated (4 statuses)
- [ ] getUnfiredSetups returns only planted/referenced setups
</verification>

<success_criteria>
- All tasks completed
- Both modules follow established patterns from Phases 3-4
- Self-tests verify all CRUD operations
- getUnfiredSetups specialized query works correctly
- No errors or warnings introduced
</success_criteria>

<output>
After completion, create `.planning/phases/05-logic-modules-motifs-setups-rules/05-01-SUMMARY.md`
</output>
