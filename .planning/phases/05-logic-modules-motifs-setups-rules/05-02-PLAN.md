---
phase: 05-logic-modules-motifs-setups-rules
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [db/modules/world-rules.js]
autonomous: true

must_haves:
  truths:
    - "World rules can be created and retrieved by project"
    - "Rule categories are validated (physics, magic, technology, social, biological, metaphysical)"
    - "Enforcement levels are validated (strict, flexible, guideline)"
    - "World rules support exceptions documentation"
  artifacts:
    - path: "db/modules/world-rules.js"
      provides: "Universe consistency tracking with CRUD operations"
      min_lines: 80
      exports: ["createWorldRule", "getWorldRulesByProject", "getWorldRulesByCategory", "getWorldRuleById", "updateWorldRule", "deleteWorldRule"]
  key_links:
    - from: "world-rules.js"
      to: "WORLD_RULES table"
      via: "db.prepare() and INSERT/SELECT statements"
      pattern: "db\\.prepare\\(.*world_rules"
    - from: "createWorldRule"
      to: "rule_category and enforcement_level validation"
      via: "RULE_CATEGORIES and ENFORCEMENT_LEVELS constants"
      pattern: "RULE_CATEGORIES.*includes.*ENFORCEMENT_LEVELS.*includes"
---

<objective>
Create world-rules.js module for universe consistency tracking across 6 rule categories with enforcement levels.

Purpose: Complete final module in Phase 5, enabling world-building consistency tracking for physics, magic, technology, social norms, biology, and metaphysics. This module completes the third wave of logic layer modules.

Output: Database module with full CRUD operations, category filtering, and self-test.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/CONVENTIONS.md

# Prior logic layer modules (established patterns):
@.planning/phases/03-logic-layer-modules-causality-arcs/03-01-SUMMARY.md
@.planning/phases/04-logic-modules-conflicts-themes/04-01-SUMMARY.md

# Schema reference:
@db/migrations/006_logic_layer.sql

# Existing modules (pattern reference):
@db/modules/story-conflicts.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create world-rules.js module</name>
  <files>db/modules/world-rules.js</files>
  <action>
    Create world-rules.js following established module factory pattern:

    **Module structure:**
    - Require uuid (for UUID generation)
    - Define RULE_CATEGORIES constant: ['physics', 'magic', 'technology', 'social', 'biological', 'metaphysical']
    - Define ENFORCEMENT_LEVELS constant: ['strict', 'flexible', 'guideline']
    - Export factory function: `module.exports = (db) => { ... }`

    **Functions to implement (6 total):**

    1. `createWorldRule({ project_id, rule_category, statement, exceptions, enforcement_level = 'strict' })`:
       - Validate rule_category against RULE_CATEGORIES array
       - Validate enforcement_level against ENFORCEMENT_LEVELS array
       - Generate rule_uuid with uuidv4()
       - Set created_at with Date.now()
       - INSERT into world_rules table
       - Return created rule object

    2. `getWorldRulesByProject(project_id)`:
       - SELECT all columns WHERE project_id = ?
       - Return array of rule objects

    3. `getWorldRulesByCategory(project_id, rule_category)`:
       - Validate rule_category against RULE_CATEGORIES
       - SELECT all columns WHERE project_id = ? AND rule_category = ?
       - Return array of rule objects filtered by category

    4. `getWorldRuleById(rule_uuid)`:
       - SELECT all columns WHERE rule_uuid = ?
       - Return single rule object or undefined

    5. `updateWorldRule(rule_uuid, updates)`:
       - Whitelist allowed fields: statement, exceptions, enforcement_level
       - Validate rule_category if present in updates (should NOT be updatable - world rule category is immutable)
       - Validate enforcement_level if present in updates
       - Build dynamic UPDATE statement
       - Return updated rule object

    6. `deleteWorldRule(rule_uuid)`:
       - DELETE FROM world_rules WHERE rule_uuid = ?
       - Return { deleted: true }

    **Validation:**
    - Throw descriptive errors for invalid rule_category (include RULE_CATEGORIES.join(', ') in message)
    - Throw descriptive errors for invalid enforcement_level (include ENFORCEMENT_LEVELS.join(', ') in message)
    - Validate before database interaction (fail fast)

    **Documentation:**
    - Add JSDoc comments for all exported functions
    - Document enforcement_level meanings: strict (immutable physics), flexible (social norms with exceptions), guideline (soft rules)
    - Include parameter types and descriptions
    - Document return types

    **Self-test:**
    - Add `if (require.main === module)` block at end
    - Create in-memory database with schema
    - Test all 6 functions
    - Include assertions for: creation, retrieval by project/category/ID, update (including enforcement_level change), delete, category validation, enforcement_level validation

    **Pattern references:**
    - Use db/modules/story-conflicts.js as template for structure
    - Follow same naming conventions (camelCase functions, snake_case columns)
    - Use prepared statements for all queries
    - Exception handling pattern: exceptions field is optional TEXT (can be NULL)
  </action>
  <verify>node db/modules/world-rules.js runs self-test without errors</verify>
  <done>world-rules.js exports 6 functions, self-test passes with 9+ assertions covering categories, enforcement levels, and exceptions</done>
</task>

<task type="auto">
  <name>Task 2: Verify Phase 5 completion</name>
  <files>db/modules/motif-instances.js, db/modules/setup-payoffs.js, db/modules/world-rules.js</files>
  <action>
    Run all three module self-tests sequentially to verify Phase 5 completion:

    **Test execution:**
    1. Run `node db/modules/motif-instances.js` and verify output shows passing assertions
    2. Run `node db/modules/setup-payoffs.js` and verify output shows passing assertions
    3. Run `node db/modules/world-rules.js` and verify output shows passing assertions

    **Verification criteria:**
    - All modules execute without errors
    - All assertions pass
    - No database errors or constraint violations
    - Self-tests demonstrate full CRUD operations

    **Expected output format:**
    Each module should print test results showing:
    - ✓ Create function works
    - ✓ Get by project works
    - ✓ Get by ID works
    - ✓ Update works
    - ✓ Delete works
    - ✓ Specialized queries work (unfired setups, category filtering)
    - ✓ Validation works (type/category/enforcement_level)

    If any test fails, debug and fix before marking plan complete.
  </action>
  <verify>All three modules run self-tests successfully with no errors</verify>
  <done>All Phase 5 modules verified working with self-tests passing</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] world-rules.js created with correct exports
- [ ] Self-test passes for world-rules.js
- [ ] Rule categories validated (6 categories)
- [ ] Enforcement levels validated (3 levels)
- [ ] All three Phase 5 modules tested and working
</verification>

<success_criteria>
- All tasks completed
- world-rules.js follows established patterns from Phases 3-4
- Self-test verifies all CRUD operations
- Category filtering works correctly
- Phase 5 complete: motif-instances.js, setup-payoffs.js, world-rules.js all operational
- No errors or warnings introduced
</success_criteria>

<output>
After completion, create `.planning/phases/05-logic-modules-motifs-setups-rules/05-02-SUMMARY.md`
</output>
