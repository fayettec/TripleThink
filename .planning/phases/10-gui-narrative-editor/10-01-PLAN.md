---
phase: 10-gui-narrative-editor
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - gui/js/components/narrative-tree-editor.js
  - gui/js/api-client.js
autonomous: true

must_haves:
  truths:
    - "User can see a tree view of chapters and scenes"
    - "User can drag a scene within a chapter"
    - "Drag interaction updates scene order in database"
  artifacts:
    - path: "gui/js/components/narrative-tree-editor.js"
      provides: "Drag-and-drop tree editor for narrative structure"
      exports: ["NarrativeTreeEditor"]
      min_lines: 150
    - path: "gui/js/api-client.js"
      provides: "API methods for narrative operations"
      contains: "updateSceneSequence"
  key_links:
    - from: "narrative-tree-editor.js"
      to: "api.updateSceneSequence"
      via: "drag end handler"
      pattern: "api\\.updateSceneSequence"
---

<objective>
Create narrative tree editor component with drag-and-drop foundation and API client methods.

Purpose: Build the foundational component for drag-and-drop chapter/scene reordering (GUI-14). This enables visual tree representation and basic drag interactions. API methods provide backend integration for all narrative operations.

Output: NarrativeTreeEditor component with drag-and-drop rendering, API client methods for update/split/merge/rename/delete operations.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/STRUCTURE.md
@.planning/codebase/CONVENTIONS.md

**Prior Phase Context:**
Phase 9 established card component pattern (arc-card.js, conflict-card.js) with render() methods returning HTML strings. Follow same pattern for tree rendering.

Phase 8 established API client pattern with request() method and error handling. Extend with narrative methods.

**Existing Infrastructure:**
- db/modules/scenes.js: Scene CRUD with chapterId, sceneNumber fields
- api/routes/orchestrator.js: Scene endpoints (GET/POST/PATCH/DELETE /scenes)
- gui/js/api-client.js: Generic request() method

**Requirements:**
- GUI-14: narrative-tree-editor.js component supports drag-and-drop chapter/scene reordering
- GUI-19: narrative.js screen integrates narrative-tree-editor.js (Plan 03 will complete)

**Narrative Structure:**
Scenes have:
- id (UUID)
- fictionId
- chapterId (nullable - scenes can be unassigned)
- sceneNumber (integer for ordering)
- title, summary, status

Chapters are logical groupings - scenes with same chapterId belong to that chapter.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create narrative-tree-editor.js with drag-and-drop tree rendering</name>
  <files>gui/js/components/narrative-tree-editor.js</files>
  <action>
    Create gui/js/components/narrative-tree-editor.js as a component object with render() method:

    **Structure:**
    ```javascript
    const NarrativeTreeEditor = {
      data: {
        chapters: [], // Array of {id, title, scenes: [...]}
        selectedNodeId: null,
        draggedNodeId: null
      },

      render(fictionId) {
        // Fetch chapters and scenes from API
        // Build tree structure: group scenes by chapterId
        // Return HTML string with drag-and-drop tree
      },

      renderChapter(chapter) {
        // Render chapter node with draggable attribute
        // Include chapter title and scene count
        // Return HTML string
      },

      renderScene(scene) {
        // Render scene node with draggable attribute
        // Include scene number, title, status badge
        // Return HTML string
      },

      setupDragHandlers() {
        // Add event listeners for dragstart, dragover, drop, dragend
        // Store dragged node ID in draggedNodeId
        // Update visual feedback during drag
      },

      handleDrop(event, targetId, targetType) {
        // Determine if dropping on chapter or scene
        // Calculate new sequence numbers
        // Call api.updateSceneSequence() to persist
        // Re-render tree after successful update
      }
    };
    ```

    **Drag-and-drop implementation:**
    Use HTML5 Drag and Drop API:
    - Set draggable="true" on chapter/scene nodes
    - dragstart: Store node ID and type (chapter/scene)
    - dragover: Allow drop, add visual indicator (border highlight)
    - drop: Call handleDrop() to update sequence
    - dragend: Clear visual indicators

    **Tree structure:**
    ```html
    <div class="narrative-tree">
      <div class="tree-chapter" draggable="true" data-id="ch-1">
        <div class="chapter-header">
          <span class="chapter-number">Chapter 1</span>
          <span class="chapter-title">The Beginning</span>
          <span class="scene-count">(3 scenes)</span>
        </div>
        <div class="chapter-scenes">
          <div class="tree-scene" draggable="true" data-id="scene-uuid-1">
            <span class="scene-number">1</span>
            <span class="scene-title">Opening Scene</span>
            <span class="scene-status badge">draft</span>
          </div>
          <!-- More scenes... -->
        </div>
      </div>
      <!-- More chapters... -->
    </div>
    ```

    **Initial fetch:**
    On render(), call `await api.getScenesByFiction(fictionId)`, group by chapterId, sort by sceneNumber.

    **Component pattern:**
    Follow Phase 9 pattern - static object with render() method, DOM manipulation via vanilla JS.

    **Styling:**
    Add basic CSS in component or reference from components.css:
    - .narrative-tree: padding, margin
    - .tree-chapter: margin-bottom, border
    - .tree-scene: padding-left for indent, hover state
    - .dragging: opacity 0.5 during drag
    - .drop-target: border highlight during dragover
  </action>
  <verify>
    - narrative-tree-editor.js exports NarrativeTreeEditor object
    - Component has render(fictionId) method
    - Drag-and-drop handlers registered via setupDragHandlers()
    - Tree renders with chapters and nested scenes
  </verify>
  <done>
    Component renders tree, drag interactions work (visual feedback), handleDrop() logs intended changes (API call in Task 2)
  </done>
</task>

<task type="auto">
  <name>Task 2: Add narrative API methods to api-client.js</name>
  <files>gui/js/api-client.js</files>
  <action>
    Extend gui/js/api-client.js with narrative operation methods:

    **Add section comment:**
    ```javascript
    // ============================================================
    // NARRATIVE STRUCTURE ENDPOINTS
    // ============================================================
    ```

    **Methods to add:**

    ```javascript
    /**
     * Get all scenes for a fiction
     * @param {string} fictionId - Fiction UUID
     * @returns {Promise<array>} Array of scenes
     */
    async getScenesByFiction(fictionId) {
      return this.request(`/api/orchestrator/fictions/${fictionId}/scenes`);
    }

    /**
     * Update scene sequence number
     * @param {string} sceneId - Scene UUID
     * @param {object} data - {sceneNumber, chapterId}
     * @returns {Promise<object>} Updated scene
     */
    async updateSceneSequence(sceneId, data) {
      return this.request(`/api/orchestrator/scenes/${sceneId}`, {
        method: 'PATCH',
        body: data
      });
    }

    /**
     * Batch update scene sequences (for renumbering)
     * @param {array} updates - Array of {sceneId, sceneNumber, chapterId}
     * @returns {Promise<object>} Batch result
     */
    async batchUpdateScenes(updates) {
      return this.request('/api/orchestrator/scenes/batch', {
        method: 'PATCH',
        body: { updates }
      });
    }

    /**
     * Split chapter at scene index
     * @param {string} chapterId - Chapter ID
     * @param {number} splitIndex - Scene index to split at
     * @returns {Promise<object>} New chapter and updated scenes
     */
    async splitChapter(chapterId, splitIndex) {
      return this.request(`/api/orchestrator/chapters/${chapterId}/split`, {
        method: 'POST',
        body: { splitIndex }
      });
    }

    /**
     * Merge two chapters
     * @param {string} chapter1Id - First chapter ID
     * @param {string} chapter2Id - Second chapter ID
     * @returns {Promise<object>} Merged chapter and updated scenes
     */
    async mergeChapters(chapter1Id, chapter2Id) {
      return this.request(`/api/orchestrator/chapters/merge`, {
        method: 'POST',
        body: { chapter1Id, chapter2Id }
      });
    }

    /**
     * Rename chapter or scene
     * @param {string} id - Chapter or scene ID
     * @param {string} type - 'chapter' or 'scene'
     * @param {string} newTitle - New title
     * @returns {Promise<object>} Updated entity
     */
    async renameNarrativeNode(id, type, newTitle) {
      const endpoint = type === 'chapter'
        ? `/api/orchestrator/chapters/${id}`
        : `/api/orchestrator/scenes/${id}`;
      return this.request(endpoint, {
        method: 'PATCH',
        body: { title: newTitle }
      });
    }

    /**
     * Delete chapter or scene
     * @param {string} id - Chapter or scene ID
     * @param {string} type - 'chapter' or 'scene'
     * @returns {Promise<void>}
     */
    async deleteNarrativeNode(id, type) {
      const endpoint = type === 'chapter'
        ? `/api/orchestrator/chapters/${id}`
        : `/api/orchestrator/scenes/${id}`;
      return this.request(endpoint, {
        method: 'DELETE'
      });
    }
    ```

    **Note on API endpoints:**
    These endpoints may not all exist yet. If orchestrator.js doesn't have chapter routes, add TODO comments and use scene routes where possible. Plan 02 will implement missing operations if needed.

    Existing: GET/POST/PATCH/DELETE for scenes in orchestrator.js
    May need: Chapter-specific routes for split/merge (Plan 02 will add if missing)
  </action>
  <verify>
    - api-client.js has narrative section with 7+ methods
    - Methods use request() with proper HTTP verbs
    - JSDoc comments explain parameters and returns
    - Pattern matches existing API client methods (causality, arcs, etc.)
  </verify>
  <done>
    API client has complete narrative methods, ready for use in tree editor
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] NarrativeTreeEditor component exists with render() method
- [ ] Tree renders with chapters and scenes from API data
- [ ] Drag-and-drop handlers registered and functional
- [ ] API client has 7+ narrative methods with proper structure
- [ ] No TypeScript/linting errors
</verification>

<success_criteria>

- NarrativeTreeEditor component created with drag-and-drop foundation
- API client extended with narrative operation methods
- Tree renders correctly from fiction data
- Drag interactions provide visual feedback
- Code follows vanilla JS component pattern from Phase 9
  </success_criteria>

<output>
After completion, create `.planning/phases/10-gui-narrative-editor/10-01-SUMMARY.md`
</output>
