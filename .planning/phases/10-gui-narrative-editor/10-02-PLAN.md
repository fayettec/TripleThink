---
phase: 10-gui-narrative-editor
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - gui/js/components/narrative-tree-editor.js
  - api/routes/orchestrator.js
  - gui/styles/components.css
autonomous: true

must_haves:
  truths:
    - "Scene numbers update automatically after drag-and-drop"
    - "User can split a chapter into two chapters"
    - "User can merge two adjacent chapters"
    - "Chapter numbers update automatically after operations"
  artifacts:
    - path: "gui/js/components/narrative-tree-editor.js"
      provides: "Auto-renumbering, split, and merge operations"
      contains: "renumberScenes"
    - path: "api/routes/orchestrator.js"
      provides: "Chapter split and merge endpoints"
      contains: "router.post.*split"
  key_links:
    - from: "narrative-tree-editor.js"
      to: "renumberScenes"
      via: "after drag drop or split/merge"
      pattern: "renumberScenes"
    - from: "split button click"
      to: "api.splitChapter"
      via: "event handler"
      pattern: "splitChapter"
---

<objective>
Implement auto-renumbering after drag operations and add split/merge chapter functionality.

Purpose: Complete GUI-15 (auto-renumbering), GUI-16 (split chapter), GUI-17 (merge chapter). After drag-and-drop reordering, scene numbers must update automatically. Users need UI for splitting one chapter into two and merging two chapters into one.

Output: Working auto-renumbering on drop, split chapter UI with backend support, merge chapter UI with backend support.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-gui-narrative-editor/10-01-SUMMARY.md

**From Plan 01:**
- NarrativeTreeEditor component with drag-and-drop
- API client methods for narrative operations (including splitChapter, mergeChapters)
- Tree renders chapters and scenes from API

**Requirements:**
- GUI-15: Narrative tree editor auto-renumbers chapters/scenes after reorder
- GUI-16: Narrative tree editor supports split chapter operation
- GUI-17: Narrative tree editor supports merge chapter operation

**Renumbering Logic:**
After drag-and-drop:
1. Determine affected chapters (source and destination)
2. Recalculate scene numbers for affected chapters
3. Batch update via api.batchUpdateScenes()
4. Re-render tree

**Split Chapter:**
User selects a chapter, chooses "Split at scene X". Result:
- Original chapter keeps scenes 1 to X-1
- New chapter created with scenes X to end
- All subsequent chapters renumbered (Chapter 3 ‚Üí 4, etc.)

**Merge Chapter:**
User selects two adjacent chapters, chooses "Merge". Result:
- Second chapter's scenes moved to first chapter
- Scene numbers recalculated (first chapter now has combined scenes)
- Second chapter deleted
- Subsequent chapters renumbered
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement auto-renumbering after drag-and-drop</name>
  <files>gui/js/components/narrative-tree-editor.js</files>
  <action>
    Enhance NarrativeTreeEditor with renumbering logic:

    **Add renumberScenes() method:**
    ```javascript
    async renumberScenes(chapterId) {
      // Get all scenes for this chapter
      const chapterScenes = this.data.chapters
        .find(ch => ch.id === chapterId)?.scenes || [];

      // Build updates array: {sceneId, sceneNumber, chapterId}
      const updates = chapterScenes.map((scene, index) => ({
        sceneId: scene.id,
        sceneNumber: index + 1,
        chapterId: chapterId
      }));

      // Batch update via API
      await api.batchUpdateScenes(updates);
    }
    ```

    **Update handleDrop() method:**
    ```javascript
    async handleDrop(event, targetId, targetType) {
      event.preventDefault();
      const draggedId = this.data.draggedNodeId;
      const draggedType = this.data.draggedType;

      if (!draggedId) return;

      // Determine source and destination chapters
      let sourceChapterId, destChapterId;

      if (draggedType === 'scene') {
        // Find source chapter
        sourceChapterId = this.findChapterForScene(draggedId);

        if (targetType === 'chapter') {
          // Dropping scene onto chapter - add to end
          destChapterId = targetId;
        } else if (targetType === 'scene') {
          // Dropping scene onto another scene - insert before target
          destChapterId = this.findChapterForScene(targetId);
          const targetIndex = this.findSceneIndex(targetId);
          // Update dragged scene to insert at targetIndex
          await api.updateSceneSequence(draggedId, {
            chapterId: destChapterId,
            sceneNumber: targetIndex
          });
        }

        // Renumber affected chapters
        await this.renumberScenes(sourceChapterId);
        if (destChapterId !== sourceChapterId) {
          await this.renumberScenes(destChapterId);
        }

        // Re-render tree
        await this.render(this.data.fictionId);
      } else if (draggedType === 'chapter') {
        // Chapter reordering
        // Find all chapters, swap positions
        const draggedChapter = this.data.chapters.find(ch => ch.id === draggedId);
        const targetChapter = this.data.chapters.find(ch => ch.id === targetId);
        // Swap chapter numbers, call API to update
        // (Simplified - actual implementation depends on chapter schema)
        console.log('Chapter reordering not fully implemented yet');
      }

      // Clear drag state
      this.data.draggedNodeId = null;
      this.data.draggedType = null;
      event.target.classList.remove('drop-target');
    }
    ```

    **Helper methods:**
    ```javascript
    findChapterForScene(sceneId) {
      for (const chapter of this.data.chapters) {
        if (chapter.scenes.some(s => s.id === sceneId)) {
          return chapter.id;
        }
      }
      return null;
    }

    findSceneIndex(sceneId) {
      for (const chapter of this.data.chapters) {
        const index = chapter.scenes.findIndex(s => s.id === sceneId);
        if (index !== -1) return index;
      }
      return 0;
    }
    ```

    **dragstart handler update:**
    Store both draggedNodeId and draggedType (scene or chapter):
    ```javascript
    handleDragStart(event) {
      this.data.draggedNodeId = event.target.dataset.id;
      this.data.draggedType = event.target.dataset.type; // 'scene' or 'chapter'
      event.target.classList.add('dragging');
    }
    ```

    **Verification:**
    After drop, verify scene numbers are sequential (1, 2, 3...) within each chapter.
  </action>
  <verify>
    - Drag scene to different position, observe renumbering
    - Drag scene to different chapter, observe both chapters renumber
    - Check API calls: batchUpdateScenes called with correct data
    - Verify no duplicate scene numbers within a chapter
  </verify>
  <done>
    Dragging scenes triggers automatic renumbering, scene numbers remain sequential within each chapter
  </done>
</task>

<task type="auto">
  <name>Task 2: Add split chapter operation UI and logic</name>
  <files>gui/js/components/narrative-tree-editor.js, api/routes/orchestrator.js</files>
  <action>
    **Part A: Add split UI to NarrativeTreeEditor**

    Update renderChapter() to include split button:
    ```javascript
    renderChapter(chapter) {
      return `
        <div class="tree-chapter" draggable="true" data-id="${chapter.id}" data-type="chapter">
          <div class="chapter-header">
            <span class="chapter-number">Chapter ${chapter.number}</span>
            <span class="chapter-title">${chapter.title || 'Untitled'}</span>
            <span class="scene-count">(${chapter.scenes.length} scenes)</span>
            <button class="btn-icon" onclick="NarrativeTreeEditor.showSplitDialog('${chapter.id}')" title="Split Chapter">
              ‚úÇÔ∏è
            </button>
          </div>
          <div class="chapter-scenes">
            ${chapter.scenes.map(scene => this.renderScene(scene)).join('')}
          </div>
        </div>
      `;
    }
    ```

    **Add showSplitDialog() method:**
    ```javascript
    showSplitDialog(chapterId) {
      const chapter = this.data.chapters.find(ch => ch.id === chapterId);
      if (!chapter || chapter.scenes.length < 2) {
        alert('Chapter must have at least 2 scenes to split');
        return;
      }

      // Simple prompt for split index (could be enhanced with modal)
      const splitIndex = prompt(`Split chapter "${chapter.title}" at scene number (2-${chapter.scenes.length}):`);
      const index = parseInt(splitIndex, 10);

      if (isNaN(index) || index < 2 || index > chapter.scenes.length) {
        alert('Invalid split index');
        return;
      }

      this.splitChapter(chapterId, index);
    }
    ```

    **Add splitChapter() method:**
    ```javascript
    async splitChapter(chapterId, splitIndex) {
      try {
        // Call API to split chapter
        await api.splitChapter(chapterId, splitIndex);

        // Re-render tree
        await this.render(this.data.fictionId);

        console.log(`Chapter split at scene ${splitIndex}`);
      } catch (err) {
        console.error('Split chapter failed:', err);
        alert(`Failed to split chapter: ${err.message}`);
      }
    }
    ```

    **Part B: Add split endpoint to orchestrator.js**

    Check if api/routes/orchestrator.js has chapter split endpoint. If not, add:

    ```javascript
    // Split chapter at scene index
    router.post('/chapters/:chapterId/split', async (req, res) => {
      const { chapterId } = req.params;
      const { splitIndex } = req.body;

      // Validate splitIndex
      if (!splitIndex || splitIndex < 2) {
        return res.status(400).json({ error: 'splitIndex must be >= 2' });
      }

      // Get all scenes for this chapter
      const chapterScenes = scenes.getScenesInFiction(db, req.body.fictionId, { chapterId });

      if (chapterScenes.length < 2) {
        return res.status(400).json({ error: 'Chapter must have at least 2 scenes' });
      }

      if (splitIndex > chapterScenes.length) {
        return res.status(400).json({ error: `splitIndex ${splitIndex} exceeds scene count ${chapterScenes.length}` });
      }

      // Create new chapter ID
      const newChapterId = `ch-${Date.now()}`;

      // Update scenes: scenes[splitIndex-1:] move to new chapter
      const scenesToMove = chapterScenes.slice(splitIndex - 1);
      for (const scene of scenesToMove) {
        await scenes.updateScene(db, scene.id, { chapterId: newChapterId });
      }

      // Renumber scenes in both chapters
      const remainingScenes = chapterScenes.slice(0, splitIndex - 1);
      remainingScenes.forEach((scene, index) => {
        scenes.updateScene(db, scene.id, { sceneNumber: index + 1 });
      });
      scenesToMove.forEach((scene, index) => {
        scenes.updateScene(db, scene.id, { sceneNumber: index + 1 });
      });

      res.json({
        originalChapter: chapterId,
        newChapter: newChapterId,
        scenesMoved: scenesToMove.length
      });
    });
    ```

    **Note:** If chapters are not stored in a separate table, scenes with same chapterId form a logical chapter. The split operation just changes chapterId for some scenes.
  </action>
  <verify>
    - Split button appears on chapter headers
    - Clicking split button shows dialog
    - Entering valid split index splits chapter
    - API endpoint returns success
    - Tree re-renders with two chapters
  </verify>
  <done>
    User can split a chapter, scenes move to new chapter, tree updates automatically
  </done>
</task>

<task type="auto">
  <name>Task 3: Add merge chapter operation UI and logic</name>
  <files>gui/js/components/narrative-tree-editor.js, api/routes/orchestrator.js, gui/styles/components.css</files>
  <action>
    **Part A: Add merge UI to NarrativeTreeEditor**

    Update renderChapter() to include merge button (only show if not last chapter):
    ```javascript
    renderChapter(chapter, isLastChapter) {
      return `
        <div class="tree-chapter" draggable="true" data-id="${chapter.id}" data-type="chapter">
          <div class="chapter-header">
            <span class="chapter-number">Chapter ${chapter.number}</span>
            <span class="chapter-title">${chapter.title || 'Untitled'}</span>
            <span class="scene-count">(${chapter.scenes.length} scenes)</span>
            <button class="btn-icon" onclick="NarrativeTreeEditor.showSplitDialog('${chapter.id}')" title="Split Chapter">
              ‚úÇÔ∏è
            </button>
            ${!isLastChapter ? `
              <button class="btn-icon" onclick="NarrativeTreeEditor.mergeWithNext('${chapter.id}')" title="Merge with Next Chapter">
                üîó
              </button>
            ` : ''}
          </div>
          <div class="chapter-scenes">
            ${chapter.scenes.map(scene => this.renderScene(scene)).join('')}
          </div>
        </div>
      `;
    }
    ```

    **Add mergeWithNext() method:**
    ```javascript
    async mergeWithNext(chapterId) {
      const chapterIndex = this.data.chapters.findIndex(ch => ch.id === chapterId);
      if (chapterIndex === -1 || chapterIndex === this.data.chapters.length - 1) {
        alert('Cannot merge last chapter');
        return;
      }

      const currentChapter = this.data.chapters[chapterIndex];
      const nextChapter = this.data.chapters[chapterIndex + 1];

      const confirmed = confirm(`Merge "${currentChapter.title}" with "${nextChapter.title}"? This will combine all scenes into ${currentChapter.title}.`);
      if (!confirmed) return;

      try {
        // Call API to merge chapters
        await api.mergeChapters(chapterId, nextChapter.id);

        // Re-render tree
        await this.render(this.data.fictionId);

        console.log(`Chapters merged: ${chapterId} + ${nextChapter.id}`);
      } catch (err) {
        console.error('Merge chapters failed:', err);
        alert(`Failed to merge chapters: ${err.message}`);
      }
    }
    ```

    **Part B: Add merge endpoint to orchestrator.js**

    ```javascript
    // Merge two chapters
    router.post('/chapters/merge', async (req, res) => {
      const { chapter1Id, chapter2Id } = req.body;

      if (!chapter1Id || !chapter2Id) {
        return res.status(400).json({ error: 'Both chapter1Id and chapter2Id required' });
      }

      // Get scenes for both chapters
      const chapter1Scenes = scenes.getScenesInFiction(db, req.body.fictionId, { chapterId: chapter1Id });
      const chapter2Scenes = scenes.getScenesInFiction(db, req.body.fictionId, { chapterId: chapter2Id });

      // Move all chapter2 scenes to chapter1
      for (const scene of chapter2Scenes) {
        await scenes.updateScene(db, scene.id, { chapterId: chapter1Id });
      }

      // Renumber all scenes in merged chapter
      const allScenes = [...chapter1Scenes, ...chapter2Scenes];
      allScenes.forEach((scene, index) => {
        scenes.updateScene(db, scene.id, { sceneNumber: index + 1 });
      });

      res.json({
        mergedChapter: chapter1Id,
        deletedChapter: chapter2Id,
        totalScenes: allScenes.length
      });
    });
    ```

    **Part C: Add CSS for button icons**

    Add to gui/styles/components.css:
    ```css
    /* Narrative tree editor buttons */
    .chapter-header .btn-icon {
      background: none;
      border: none;
      font-size: 16px;
      cursor: pointer;
      padding: 4px 8px;
      margin-left: 8px;
      opacity: 0.6;
      transition: opacity 0.2s;
    }

    .chapter-header .btn-icon:hover {
      opacity: 1;
    }

    .tree-chapter {
      margin-bottom: 16px;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 12px;
      background: var(--card-background);
    }

    .chapter-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--border-color);
      margin-bottom: 8px;
    }

    .chapter-scenes {
      padding-left: 24px;
    }

    .tree-scene {
      padding: 8px;
      margin: 4px 0;
      border-radius: 4px;
      background: var(--background-light);
      cursor: grab;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .tree-scene.dragging {
      opacity: 0.5;
    }

    .tree-scene.drop-target {
      border: 2px dashed var(--primary-color);
    }

    .scene-number {
      font-weight: bold;
      color: var(--text-muted);
      min-width: 24px;
    }

    .scene-status.badge {
      font-size: 12px;
      padding: 2px 8px;
      border-radius: 12px;
      background: var(--badge-background);
      color: var(--badge-text);
    }
    ```
  </action>
  <verify>
    - Merge button (üîó) appears on all chapters except last
    - Clicking merge shows confirmation dialog
    - Confirming merge combines chapters
    - API endpoint returns success
    - Tree re-renders with merged chapter
  </verify>
  <done>
    User can merge adjacent chapters, scenes move to first chapter, tree updates automatically, CSS provides visual polish
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Drag-and-drop triggers renumbering
- [ ] Scene numbers are sequential after reorder
- [ ] Split chapter UI and API work correctly
- [ ] Merge chapter UI and API work correctly
- [ ] CSS provides visual feedback for drag and buttons
- [ ] No errors during split/merge operations
</verification>

<success_criteria>

- Auto-renumbering works after drag-and-drop (GUI-15)
- Split chapter operation functional (GUI-16)
- Merge chapter operation functional (GUI-17)
- Tree updates correctly after all operations
- CSS provides polished visual experience
  </success_criteria>

<output>
After completion, create `.planning/phases/10-gui-narrative-editor/10-02-SUMMARY.md`
</output>
