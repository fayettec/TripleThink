---
phase: 04-logic-modules-conflicts-themes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [db/modules/story-conflicts.js]
autonomous: true

# Goal-backward verification
must_haves:
  truths:
    - "User can create story conflicts with type, protagonist, antagonist, and stakes"
    - "User can transition conflicts through status phases (latent → active → escalating → climactic → resolved)"
    - "Conflict module validates conflict types (5 valid types) and status values (5 valid statuses)"
    - "Module functions throw errors for invalid inputs before touching database"
  artifacts:
    - path: "db/modules/story-conflicts.js"
      provides: "Story conflict CRUD operations with status transitions"
      min_lines: 100
      exports: ["createConflict", "getConflictsByProject", "getConflictsByProtagonist", "getConflictById", "updateConflict", "deleteConflict", "transitionConflictStatus"]
  key_links:
    - from: "story-conflicts.js createConflict"
      to: "STORY_CONFLICTS table"
      via: "INSERT prepared statement"
      pattern: "db\\.prepare.*INSERT INTO story_conflicts"
    - from: "story-conflicts.js transitionConflictStatus"
      to: "STORY_CONFLICTS table status field"
      via: "UPDATE with status validation"
      pattern: "UPDATE story_conflicts SET status"
---

<objective>
Create complete story-conflicts.js module with CRUD operations and status transition helpers for conflict tracking.

Purpose: Enable tracking of 5 conflict types (internal, interpersonal, societal, environmental, supernatural) with clear stakes and status progression through narrative phases.

Output: Working database module following the pattern established in causality-chains.js and character-arcs.js, with comprehensive self-tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase summaries (patterns established)
@.planning/phases/03-logic-layer-modules-causality-arcs/03-01-SUMMARY.md
@.planning/phases/03-logic-layer-modules-causality-arcs/03-02-SUMMARY.md

# Database schema reference
@db/migrations/006_logic_layer.sql

# Codebase conventions
@.planning/codebase/CONVENTIONS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create story-conflicts.js with CRUD operations</name>
  <files>db/modules/story-conflicts.js</files>
  <action>
    Create db/modules/story-conflicts.js following the module factory pattern from causality-chains.js and character-arcs.js.

    **Module structure:**
    - Module factory: function taking db parameter, returns object with methods
    - Import better-sqlite3 for type hints only (Database type)
    - JSDoc comments for all exported functions

    **Implement 6 CRUD functions:**

    1. **createConflict({ project_id, type, protagonist_id, antagonist_source, stakes_success, stakes_fail, status = 'latent' })**
       - Validate type is one of: 'internal', 'interpersonal', 'societal', 'environmental', 'supernatural'
       - Validate status is one of: 'latent', 'active', 'escalating', 'climactic', 'resolved'
       - Generate conflict_uuid using crypto.randomUUID()
       - Use Date.now() for created_at
       - INSERT prepared statement
       - Return created conflict object
       - Throw clear error messages for invalid type/status

    2. **getConflictsByProject(project_id)**
       - SELECT all conflicts for project
       - Return array (empty if none)

    3. **getConflictsByProtagonist(protagonist_id)**
       - SELECT all conflicts where protagonist_id matches
       - Return array (empty if none)
       - Useful for character-focused queries

    4. **getConflictById(conflict_uuid)**
       - SELECT single conflict by UUID
       - Return conflict object or null if not found

    5. **updateConflict(conflict_uuid, updates)**
       - Dynamic UPDATE with validated fields
       - Allowed fields: type, antagonist_source, stakes_success, stakes_fail, status
       - Immutable fields: conflict_uuid, project_id, protagonist_id, created_at
       - Validate type and status if present in updates
       - Return updated row count (1 if successful, 0 if not found)

    6. **deleteConflict(conflict_uuid)**
       - DELETE by UUID
       - Return boolean (true if deleted, false if not found)

    **Validation constants:**
    - CONFLICT_TYPES array: ['internal', 'interpersonal', 'societal', 'environmental', 'supernatural']
    - CONFLICT_STATUSES array: ['latent', 'active', 'escalating', 'climactic', 'resolved']

    **Error handling:**
    - Throw Error with descriptive message for invalid type/status
    - Include allowed values in error message: `Invalid type '${type}'. Must be one of: ${CONFLICT_TYPES.join(', ')}`
  </action>
  <verify>
    Module file exists at db/modules/story-conflicts.js
    Functions export correctly (can be required by other modules)
    No syntax errors (node --check db/modules/story-conflicts.js)
  </verify>
  <done>
    story-conflicts.js module created with 6 CRUD functions
    Type and status validation implemented with clear error messages
    Module follows established patterns from Phase 3 modules
  </done>
</task>

<task type="auto">
  <name>Task 2: Add transitionConflictStatus helper function</name>
  <files>db/modules/story-conflicts.js</files>
  <action>
    Add transitionConflictStatus helper function to the module (7th exported function).

    **Function signature:**
    transitionConflictStatus(conflict_uuid, new_status)

    **Purpose:**
    Convenience function for GUI/API to advance conflicts through narrative phases.
    Similar to advancePhase in character-arcs.js but allows any valid status transition (non-linear storytelling support).

    **Implementation:**
    - Validate new_status is in CONFLICT_STATUSES array
    - Call updateConflict(conflict_uuid, { status: new_status })
    - Return result from updateConflict (1 if successful, 0 if conflict not found)
    - Throw error if new_status is invalid

    **Status progression reference (for documentation comment):**
    - latent: Conflict exists but hasn't surfaced yet
    - active: Conflict is now in play, characters aware
    - escalating: Stakes rising, tension increasing
    - climactic: Peak of conflict, decisive moment
    - resolved: Conflict concluded (win/loss/compromise)

    **Note:** Unlike character arc phases, conflicts can move non-sequentially (e.g., latent → climactic for sudden revelations, or escalating → resolved for quick resolutions). The function allows any valid status transition.
  </action>
  <verify>
    transitionConflictStatus function exists and is exported
    Function validates status before updating
    Invalid status throws descriptive error
  </verify>
  <done>
    transitionConflictStatus helper function added
    Conflicts can transition to any valid status (supports non-linear storytelling)
    Documentation explains 5 status phases
  </done>
</task>

<task type="auto">
  <name>Task 3: Add comprehensive self-test for story-conflicts module</name>
  <files>db/modules/story-conflicts.js</files>
  <action>
    Add self-test at bottom of module (after module.exports) following the pattern from causality-chains.js.

    **Pattern:**
    ```javascript
    if (require.main === module) {
      // Self-test code here
    }
    ```

    **Test structure:**
    1. Create in-memory SQLite database
    2. Run 006_logic_layer.sql migration to create STORY_CONFLICTS table
    3. Initialize module with test database
    4. Run assertions covering all 7 functions

    **Test cases (12+ assertions):**

    1. **createConflict - valid internal conflict**
       - Create conflict with type='internal', protagonist_id='char1'
       - Assert conflict object returned with conflict_uuid
       - Assert status defaults to 'latent'

    2. **createConflict - invalid type**
       - Try creating conflict with type='invalid_type'
       - Assert throws error with message containing 'Invalid type'

    3. **createConflict - invalid status**
       - Try creating conflict with status='invalid_status'
       - Assert throws error with message containing 'Invalid status'

    4. **getConflictsByProject**
       - Create 2 conflicts for project 'proj1'
       - Assert getConflictsByProject('proj1') returns array of length 2

    5. **getConflictsByProtagonist**
       - Create conflicts with protagonist_id='char1' and 'char2'
       - Assert getConflictsByProtagonist('char1') returns only char1's conflicts

    6. **getConflictById**
       - Retrieve conflict by UUID
       - Assert returned object matches created conflict

    7. **updateConflict - update stakes**
       - Update stakes_success and stakes_fail
       - Assert changes persisted
       - Verify protagonist_id unchanged (immutable)

    8. **transitionConflictStatus - latent to active**
       - Create latent conflict
       - Transition to 'active'
       - Assert status changed to 'active'

    9. **transitionConflictStatus - non-sequential transition**
       - Transition from 'active' to 'resolved' (skipping escalating/climactic)
       - Assert works (supports non-linear storytelling)

    10. **transitionConflictStatus - invalid status**
        - Try transitioning to 'invalid_status'
        - Assert throws error

    11. **deleteConflict**
        - Delete conflict by UUID
        - Assert returns true
        - Assert getConflictById returns null

    12. **All conflict types valid**
        - Loop through all 5 CONFLICT_TYPES
        - Create conflict for each type
        - Assert no errors

    **Output format:**
    - Print "story-conflicts.js self-test..." at start
    - Print "✓ Test N: description" for each passing assertion
    - Print "✗ Test N failed: error" if any fail
    - Print "All tests passed!" at end if successful
  </action>
  <verify>
    Run self-test: node db/modules/story-conflicts.js
    All 12+ assertions pass
    Output shows green checkmarks (✓) for all tests
  </verify>
  <done>
    Comprehensive self-test covers all 7 exported functions
    Tests validate type/status enums, CRUD operations, status transitions
    Self-test can be run standalone for verification
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] story-conflicts.js module exists with 7 exported functions
- [ ] All 5 conflict types validated (internal, interpersonal, societal, environmental, supernatural)
- [ ] All 5 status values validated (latent, active, escalating, climactic, resolved)
- [ ] Self-test runs successfully: `node db/modules/story-conflicts.js`
- [ ] Module can be imported by other modules (no syntax errors)
- [ ] Pattern matches established modules (causality-chains.js, character-arcs.js)
</verification>

<success_criteria>
- All tasks completed with atomic commits
- story-conflicts.js module functional and tested
- CRUD operations work for all 5 conflict types
- Status transitions support non-linear storytelling
- Self-test demonstrates full functionality
- Module ready for Phase 6 integration and Phase 7 API exposure
</success_criteria>

<output>
After completion, create `.planning/phases/04-logic-modules-conflicts-themes/04-01-SUMMARY.md`
</output>
