---
phase: 06-logic-layer-integration
plan: 03
type: execute
wave: 2
depends_on: ["06-01"]
files_modified: [tests/unit/logic-layer.test.js, tests/integration/logic-layer-cross-queries.test.js]
autonomous: true

must_haves:
  truths:
    - "All CRUD operations for 7 modules verified by tests"
    - "Cross-table queries (arc+conflicts, causality+themes) work correctly"
    - "Test suite runs with `npm test` and passes"
  artifacts:
    - path: "tests/unit/logic-layer.test.js"
      provides: "Unit tests for all 7 modules' CRUD operations"
      min_lines: 200
    - path: "tests/integration/logic-layer-cross-queries.test.js"
      provides: "Integration tests for cross-module queries"
      min_lines: 100
  key_links:
    - from: "unit tests"
      to: "db/api-functions.js"
      via: "require and CRUD calls"
      pattern: "api\\(db\\)\\."
    - from: "integration tests"
      to: "multiple modules"
      via: "queries spanning tables"
      pattern: "getCharacterArc.*getStoryConflict"
---

<objective>
Create comprehensive test suite for logic layer - unit tests for all CRUD operations and integration tests for cross-table queries

Purpose: Verify logic layer modules work correctly individually and together before API exposure
Output: tests/unit/logic-layer.test.js (CRUD tests) and tests/integration/logic-layer-cross-queries.test.js (cross-module tests)
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Plan 01 context - facade available
@.planning/phases/06-logic-layer-integration/06-01-SUMMARY.md

# Testing patterns
@.planning/codebase/TESTING.md

# Existing test examples
@tests/integration/event-moments.test.js
@tests/integration/orchestrator.test.js

# Database facade to test
@db/api-functions.js

# All 7 modules
@db/modules/causality-chains.js
@db/modules/character-arcs.js
@db/modules/story-conflicts.js
@db/modules/thematic-elements.js
@db/modules/motif-instances.js
@db/modules/setup-payoffs.js
@db/modules/world-rules.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create unit tests for all 7 modules' CRUD operations</name>
  <files>tests/unit/logic-layer.test.js</files>
  <action>
Create tests/unit/logic-layer.test.js following project test patterns (callback-based Mocha/assert style):

**Structure:**
```javascript
const assert = require('assert');
const Database = require('better-sqlite3');
const fs = require('fs');
const path = require('path');
const api = require('../../db/api-functions');

describe('Logic Layer Unit Tests', function() {
  this.timeout(30000);

  let db;
  let logicAPI;

  before(function(done) {
    // Create in-memory database
    db = new Database(':memory:');

    // Load schema
    const schemaPath = path.join(__dirname, '../../db/schema.sql');
    const schema = fs.readFileSync(schemaPath, 'utf8');
    db.exec(schema);

    // Initialize API
    logicAPI = api(db);

    done();
  });

  after(function(done) {
    db.close();
    done();
  });

  // Test each module's CRUD operations
  describe('Causality Chains', function() {
    it('should create causality chain', function(done) {
      const chain = logicAPI.causalityChains.createCausalityChain({
        project_id: 'proj-test',
        cause_event_id: 'evt-1',
        effect_event_id: 'evt-2',
        type: 'direct_cause',
        strength: 8,
        explanation: 'Test causality'
      });

      assert.ok(chain);
      assert.strictEqual(chain.type, 'direct_cause');
      done();
    });

    it('should get causality chains by project', function(done) {
      const chains = logicAPI.causalityChains.getCausalityChainsbyProject('proj-test');
      assert.ok(Array.isArray(chains));
      assert.ok(chains.length > 0);
      done();
    });

    // Add update and delete tests...
  });

  describe('Character Arcs', function() {
    it('should create character arc', function(done) {
      const arc = logicAPI.characterArcs.createCharacterArc({
        character_id: 'char-1',
        archetype: 'hero',
        current_phase: 'setup',
        lie_belief: 'I am weak',
        truth_belief: 'I am strong'
      });

      assert.ok(arc);
      assert.strictEqual(arc.archetype, 'hero');
      done();
    });

    // Add read, update, delete tests...
  });

  describe('Story Conflicts', function() {
    it('should create story conflict', function(done) {
      const conflict = logicAPI.storyConflicts.createStoryConflict({
        project_id: 'proj-test',
        type: 'external',
        protagonist_id: 'char-1',
        antagonist_source: 'char-2',
        stakes_success: 'Victory',
        stakes_fail: 'Defeat',
        status: 'active'
      });

      assert.ok(conflict);
      assert.strictEqual(conflict.type, 'external');
      done();
    });

    // Add read, update, delete tests...
  });

  describe('Thematic Elements', function() {
    it('should create thematic element', function(done) {
      const theme = logicAPI.thematicElements.createThematicElement({
        project_id: 'proj-test',
        statement: 'Power corrupts',
        question: 'Can power be wielded without corruption?'
      });

      assert.ok(theme);
      assert.strictEqual(theme.statement, 'Power corrupts');
      done();
    });

    // Add read, update, delete tests...
  });

  describe('Motif Instances', function() {
    it('should create motif instance', function(done) {
      const motif = logicAPI.motifInstances.createMotifInstance({
        project_id: 'proj-test',
        motif_type: 'visual',
        description: 'Red door',
        significance: 'Symbol of danger'
      });

      assert.ok(motif);
      assert.strictEqual(motif.motif_type, 'visual');
      done();
    });

    // Add read, update, delete tests...
  });

  describe('Setup Payoffs', function() {
    it('should create setup payoff', function(done) {
      const setup = logicAPI.setupPayoffs.createSetupPayoff({
        project_id: 'proj-test',
        setup_event_id: 'evt-1',
        description: 'Gun on mantelpiece',
        status: 'planted',
        planted_chapter: 1
      });

      assert.ok(setup);
      assert.strictEqual(setup.status, 'planted');
      done();
    });

    it('should get unfired setups', function(done) {
      const unfired = logicAPI.setupPayoffs.getUnfiredSetups('proj-test');
      assert.ok(Array.isArray(unfired));
      done();
    });

    // Add update, delete tests...
  });

  describe('World Rules', function() {
    it('should create world rule', function(done) {
      const rule = logicAPI.worldRules.createWorldRule({
        project_id: 'proj-test',
        rule_category: 'physics',
        statement: 'Magic requires blood sacrifice',
        enforcement_level: 'strict'
      });

      assert.ok(rule);
      assert.strictEqual(rule.rule_category, 'physics');
      done();
    });

    // Add read, update, delete tests...
  });
});
```

Add CRUD tests for each module (create, read by ID, read by project, update, delete). Aim for ~3-5 tests per module = ~25-35 total tests.

Follow project conventions: callback-based tests with `done()`, use `assert` module, create test data inline.
  </action>
  <verify>cd /app && npm test -- tests/unit/logic-layer.test.js should pass all tests</verify>
  <done>Unit tests created for all 7 modules with CRUD operation coverage</done>
</task>

<task type="auto">
  <name>Task 2: Create integration tests for cross-table queries</name>
  <files>tests/integration/logic-layer-cross-queries.test.js</files>
  <action>
Create tests/integration/logic-layer-cross-queries.test.js for queries spanning multiple logic layer tables:

**Structure:**
```javascript
const assert = require('assert');
const Database = require('better-sqlite3');
const fs = require('fs');
const path = require('path');
const api = require('../../db/api-functions');

describe('Logic Layer Integration Tests', function() {
  this.timeout(30000);

  let db;
  let logicAPI;

  before(function(done) {
    db = new Database(':memory:');
    const schemaPath = path.join(__dirname, '../../db/schema.sql');
    const schema = fs.readFileSync(schemaPath, 'utf8');
    db.exec(schema);
    logicAPI = api(db);
    done();
  });

  after(function(done) {
    db.close();
    done();
  });

  describe('Character Arc + Conflict Integration', function() {
    it('should link character arc to their primary conflict', function(done) {
      // Create character arc
      const arc = logicAPI.characterArcs.createCharacterArc({
        character_id: 'char-hero',
        archetype: 'hero',
        current_phase: 'setup'
      });

      // Create conflict with same character as protagonist
      const conflict = logicAPI.storyConflicts.createStoryConflict({
        project_id: 'proj-test',
        type: 'internal',
        protagonist_id: 'char-hero',
        status: 'active'
      });

      // Query: Get arc and verify conflict exists for same character
      const queriedArc = logicAPI.characterArcs.getCharacterArcByCharacterId('char-hero');
      const conflicts = logicAPI.storyConflicts.getStoryConflictsByProject('proj-test');
      const heroConflict = conflicts.find(c => c.protagonist_id === 'char-hero');

      assert.ok(queriedArc);
      assert.ok(heroConflict);
      assert.strictEqual(queriedArc.character_id, heroConflict.protagonist_id);
      done();
    });
  });

  describe('Causality + Theme Integration', function() {
    it('should trace causal chain and verify thematic relevance', function(done) {
      // Create causality chain
      const chain = logicAPI.causalityChains.createCausalityChain({
        project_id: 'proj-test',
        cause_event_id: 'evt-cause',
        effect_event_id: 'evt-effect',
        type: 'direct_cause',
        strength: 9
      });

      // Create theme relevant to the causality
      const theme = logicAPI.thematicElements.createThematicElement({
        project_id: 'proj-test',
        statement: 'Actions have consequences',
        question: 'Can we escape our past?'
      });

      // Query: Verify both exist in same project
      const chains = logicAPI.causalityChains.getCausalityChainsbyProject('proj-test');
      const themes = logicAPI.thematicElements.getThematicElementsByProject('proj-test');

      assert.ok(chains.length > 0);
      assert.ok(themes.length > 0);
      assert.strictEqual(chains[0].project_id, themes[0].project_id);
      done();
    });
  });

  describe('Setup Payoff + Motif Integration', function() {
    it('should track setup with motif instance as symbolic reinforcement', function(done) {
      // Create setup
      const setup = logicAPI.setupPayoffs.createSetupPayoff({
        project_id: 'proj-test',
        setup_event_id: 'evt-plant',
        description: 'Red door appears',
        status: 'planted',
        planted_chapter: 1
      });

      // Create motif for same visual element
      const motif = logicAPI.motifInstances.createMotifInstance({
        project_id: 'proj-test',
        motif_type: 'visual',
        linked_entity_id: 'evt-plant',
        description: 'Red door motif',
        significance: 'Foreshadowing danger'
      });

      // Query: Get unfired setups and motifs, verify connection via linked_entity_id
      const unfired = logicAPI.setupPayoffs.getUnfiredSetups('proj-test');
      const motifs = logicAPI.motifInstances.getMotifInstancesByProject('proj-test');

      assert.ok(unfired.length > 0);
      assert.ok(motifs.length > 0);
      assert.strictEqual(motifs[0].linked_entity_id, unfired[0].setup_event_id);
      done();
    });
  });

  describe('World Rules + Arc Phase Validation', function() {
    it('should verify character arc progression respects world rules', function(done) {
      // Create world rule about character transformation
      const rule = logicAPI.worldRules.createWorldRule({
        project_id: 'proj-test',
        rule_category: 'magic',
        statement: 'Character transformation requires catalyst event',
        enforcement_level: 'flexible'
      });

      // Create character arc
      const arc = logicAPI.characterArcs.createCharacterArc({
        character_id: 'char-transform',
        archetype: 'shapeshifter',
        current_phase: 'setup'
      });

      // Query: Verify arc exists in project with corresponding rule
      const arcs = logicAPI.characterArcs.getCharacterArcsByProject('proj-test');
      const rules = logicAPI.worldRules.getWorldRulesByProject('proj-test');

      assert.ok(arcs.length > 0);
      assert.ok(rules.length > 0);
      assert.strictEqual(arcs[0].project_id, rules[0].project_id);
      done();
    });
  });

  describe('Multi-Module Context Assembly', function() {
    it('should assemble complete logic layer context for a scene', function(done) {
      // Simulate orchestrator pattern: assemble data from multiple modules
      const projectId = 'proj-integration';
      const characterId = 'char-main';

      // Create data across modules
      logicAPI.characterArcs.createCharacterArc({
        character_id: characterId,
        archetype: 'hero',
        current_phase: 'midpoint'
      });

      logicAPI.storyConflicts.createStoryConflict({
        project_id: projectId,
        type: 'external',
        protagonist_id: characterId,
        status: 'escalating'
      });

      logicAPI.thematicElements.createThematicElement({
        project_id: projectId,
        statement: 'Courage under pressure'
      });

      logicAPI.causalityChains.createCausalityChain({
        project_id: projectId,
        cause_event_id: 'evt-choice',
        effect_event_id: 'evt-consequence',
        type: 'direct_cause',
        strength: 10
      });

      // Assemble context (orchestrator pattern)
      const context = {
        arc: logicAPI.characterArcs.getCharacterArcByCharacterId(characterId),
        conflicts: logicAPI.storyConflicts.getStoryConflictsByProject(projectId),
        themes: logicAPI.thematicElements.getThematicElementsByProject(projectId),
        causality: logicAPI.causalityChains.getCausalityChainsbyProject(projectId)
      };

      // Verify complete context
      assert.ok(context.arc);
      assert.strictEqual(context.arc.character_id, characterId);
      assert.strictEqual(context.conflicts.length, 1);
      assert.strictEqual(context.themes.length, 1);
      assert.strictEqual(context.causality.length, 1);
      done();
    });
  });
});
```

Focus on cross-module queries that orchestrator will use:
- Arc + Conflict (character's arc linked to their conflicts)
- Causality + Theme (causal relationships supporting thematic statements)
- Setup + Motif (Chekhov's gun with recurring patterns)
- World Rules + Arc (transformation rules constraining character development)
- Multi-module context assembly (simulating orchestrator's needs)

Aim for ~5-6 integration tests demonstrating cross-table functionality.
  </action>
  <verify>cd /app && npm test -- tests/integration/logic-layer-cross-queries.test.js should pass all tests</verify>
  <done>Integration tests created verifying cross-module queries work correctly</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] tests/unit/logic-layer.test.js exists with ~25-35 tests covering all CRUD operations
- [ ] tests/integration/logic-layer-cross-queries.test.js exists with ~5-6 cross-module tests
- [ ] Both test files follow project conventions (callback-based, assert module, Mocha describe/it)
- [ ] All tests pass when run with `npm test`
- [ ] Tests use in-memory database for isolation
- [ ] Tests create data inline without external fixtures
</verification>

<success_criteria>
- All tasks completed
- Comprehensive test coverage for logic layer CRUD operations
- Integration tests verify cross-module functionality
- Tests pass reliably with `npm test`
- Test structure matches existing project patterns
</success_criteria>

<output>
After completion, create `.planning/phases/06-logic-layer-integration/06-03-SUMMARY.md`
</output>
