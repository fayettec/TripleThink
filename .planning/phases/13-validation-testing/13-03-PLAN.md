---
phase: 13-validation-testing
plan: 03
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - tests/integration/api-routes-comprehensive.test.js
  - tests/e2e/qacs-workflow.test.js
  - tests/performance/storage.bench.js
autonomous: true

must_haves:
  truths:
    - "All API routes have integration tests that pass"
    - "QACS workflow succeeds end-to-end (create event → populate logic layer → assemble context → verify packet)"
    - "Storage footprint <50MB for 10-book series with full logic layer"
  artifacts:
    - path: "tests/integration/api-routes-comprehensive.test.js"
      provides: "Integration tests for all API routes"
      min_lines: 300
    - path: "tests/e2e/qacs-workflow.test.js"
      provides: "End-to-end QACS workflow tests"
      min_lines: 200
    - path: "tests/performance/storage.bench.js"
      provides: "Storage benchmarks"
      min_lines: 100
  key_links:
    - from: "api-routes-comprehensive.test.js"
      to: "all /api/* routes"
      via: "HTTP requests to all endpoints"
      pattern: "makeRequest.*api"
    - from: "qacs-workflow.test.js"
      to: "orchestrator + logic layer + database"
      via: "full integration test"
      pattern: "orchestrator.*assembleContext"
    - from: "storage.bench.js"
      to: "SQLite database file"
      via: "measures file size after population"
      pattern: "statSync.*db"
---

<objective>
Create comprehensive integration tests, end-to-end QACS workflow tests, and storage benchmarks.

Purpose: Verify all API routes work correctly, validate the complete QACS workflow (Query-Assemble-Context-Supply), and ensure storage efficiency for large series.

Output: Full integration test coverage, working E2E tests, and storage benchmarks proving <50MB for 10-book series.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Codebase context
@.planning/codebase/TESTING.md
@.planning/codebase/ARCHITECTURE.md

# Prior test patterns
@tests/integration/logic-layer-cross-queries.test.js
@tests/integration/orchestrator.test.js

# API routes to test
@api/server.js

# Orchestrator for QACS tests
@api/services/orchestrator.js

# Validation service (dependency from 13-01)
@api/services/validator.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create comprehensive API route integration tests</name>
  <files>tests/integration/api-routes-comprehensive.test.js</files>
  <action>
Create integration tests for ALL API routes (not just logic layer):

**Routes to test:**
1. /api/health - Health check
2. /api/projects - CRUD operations
3. /api/fictions - CRUD operations
4. /api/entities - CRUD operations
5. /api/metadata - CRUD operations
6. /api/epistemic - Knowledge state queries
7. /api/temporal - Timeline queries
8. /api/search - Search functionality
9. /api/export - Export operations
10. /api/validation - All 8 validation endpoints
11. /api/logic/causality - Causality chain CRUD + traversal
12. /api/logic/arcs - Character arc CRUD
13. /api/logic/conflicts - Story conflict CRUD
14. /api/logic/themes - Theme CRUD
15. /api/logic/motifs - Motif CRUD
16. /api/logic/setup-payoffs - Setup/payoff CRUD + unfired query
17. /api/logic/world-rules - World rule CRUD

**Implementation pattern:**
```javascript
const http = require('http');
const assert = require('assert');

function makeRequest(method, path, body = null) {
  return new Promise((resolve, reject) => {
    const options = {
      hostname: 'localhost',
      port: 3000,
      path: path,
      method: method,
      headers: { 'Content-Type': 'application/json' }
    };

    const req = http.request(options, (res) => {
      let data = '';
      res.on('data', chunk => { data += chunk; });
      res.on('end', () => {
        try {
          resolve({
            status: res.statusCode,
            body: data ? JSON.parse(data) : null
          });
        } catch (e) {
          resolve({ status: res.statusCode, body: data });
        }
      });
    });

    req.on('error', reject);
    if (body) req.write(JSON.stringify(body));
    req.end();
  });
}

describe('API Routes Comprehensive Integration Tests', () => {
  beforeAll(async () => {
    // Ensure server is running
    const health = await makeRequest('GET', '/health');
    assert.strictEqual(health.status, 200, 'Server must be running on port 3000');
  });

  describe('Core Routes', () => {
    test('GET /api/health returns 200 OK', async () => {
      const res = await makeRequest('GET', '/api/health');
      expect(res.status).toBe(200);
    });

    test('GET /api/projects returns array', async () => {
      const res = await makeRequest('GET', '/api/projects');
      expect(res.status).toBe(200);
      expect(Array.isArray(res.body.data)).toBe(true);
    });

    // ... 15+ more tests for each route
  });

  describe('Logic Layer Routes', () => {
    test('GET /api/logic/causality returns chains', async () => {
      const res = await makeRequest('GET', '/api/logic/causality');
      expect(res.status).toBe(200);
    });

    test('POST /api/logic/arcs creates arc', async () => {
      const res = await makeRequest('POST', '/api/logic/arcs', {
        characterId: 'char-test',
        archetype: 'hero',
        currentPhase: 'setup'
      });
      expect(res.status).toBe(201);
      expect(res.body.arcUuid).toBeDefined();
    });

    // ... 20+ more tests for logic layer
  });

  describe('Validation Routes', () => {
    test('GET /api/validation returns full report', async () => {
      const res = await makeRequest('GET', '/api/validation');
      expect(res.status).toBe(200);
      expect(res.body.summary).toBeDefined();
      expect(res.body.categories).toBeDefined();
      expect(Object.keys(res.body.categories).length).toBe(8);
    });

    test('GET /api/validation/categories returns 8 categories', async () => {
      const res = await makeRequest('GET', '/api/validation/categories');
      expect(res.status).toBe(200);
      expect(res.body.categories.length).toBe(8);
    });

    // ... 6+ more validation endpoint tests
  });
});
```

**Test coverage:**
- At least 2 tests per route (GET + POST/PUT/DELETE)
- Total: 50+ integration tests
- Verify response status, body structure, data types
  </action>
  <verify>npm test tests/integration/api-routes-comprehensive.test.js</verify>
  <done>All API routes have passing integration tests</done>
</task>

<task type="auto">
  <name>Task 2: Create end-to-end QACS workflow tests</name>
  <files>tests/e2e/qacs-workflow.test.js</files>
  <action>
Create end-to-end tests for Query-Assemble-Context-Supply workflow:

**QACS workflow:**
1. **Query:** User requests scene context
2. **Assemble:** Orchestrator collects all relevant data (entities, logic layer, epistemic states)
3. **Context:** Package assembled into complete context packet
4. **Supply:** Return context packet ready for AI scene generation

**E2E test scenarios:**

**Scenario 1: Simple scene context assembly**
```javascript
const Database = require('better-sqlite3');
const Orchestrator = require('../../api/services/orchestrator');
const createAPI = require('../../db/api-functions');

describe('QACS Workflow End-to-End Tests', () => {
  let db;
  let api;
  let orchestrator;

  beforeAll(() => {
    // Create test database with full schema
    db = new Database(':memory:');
    // ... load migrations
    api = createAPI(db);
    orchestrator = new Orchestrator(db);
  });

  afterAll(() => {
    db.close();
  });

  test('E2E: Complete QACS workflow for 2-character scene', async () => {
    // SETUP: Create test fiction
    const project = api.projects.createProject('Test Project');
    const fiction = api.fictions.createFiction(project.projectId, 'Test Fiction');

    // Create characters
    const char1 = api.entities.createEntity({
      fictionId: fiction.fictionId,
      name: 'Alice',
      type: 'character'
    });

    const char2 = api.entities.createEntity({
      fictionId: fiction.fictionId,
      name: 'Bob',
      type: 'character'
    });

    // Create event
    const event = api.entities.createEntity({
      fictionId: fiction.fictionId,
      name: 'Meeting Scene',
      type: 'event',
      timestamp: '2025-01-01T10:00:00Z'
    });

    // Populate logic layer
    const arc = api.characterArcs.createArc(
      fiction.fictionId,
      char1.id,
      'hero',
      'I am weak',
      'I am strong',
      'survive',
      'grow',
      'setup'
    );

    const conflict = api.storyConflicts.createConflict(
      fiction.fictionId,
      'interpersonal',
      char1.id,
      char2.id,
      'Alice wins argument',
      'Alice loses argument',
      'latent'
    );

    const chain = api.causalityChains.createChain(
      fiction.fictionId,
      event.id,
      event.id, // Self-reference for test
      'direct_cause',
      8,
      'Test causality'
    );

    // Add epistemic states
    api.epistemic.createKnowledgeState(
      fiction.fictionId,
      char1.id,
      event.id,
      'knows_secret',
      true
    );

    // QACS WORKFLOW TEST
    // Query: Request context for scene
    const contextRequest = {
      fictionId: fiction.fictionId,
      sceneId: event.id,
      presentEntityIds: [char1.id, char2.id],
      activeConflictIds: [conflict.conflictUuid]
    };

    // Assemble: Orchestrator collects data
    const context = await orchestrator.assembleContext(contextRequest);

    // Verify: Context packet complete and correct
    expect(context).toBeDefined();
    expect(context.scene).toBeDefined();
    expect(context.scene.id).toBe(event.id);
    expect(context.presentEntities).toHaveLength(2);
    expect(context.presentEntities[0].name).toBe('Alice');
    expect(context.presentEntities[1].name).toBe('Bob');

    // Verify logic layer data included
    expect(context.characterArcs).toBeDefined();
    expect(context.characterArcs.length).toBeGreaterThan(0);
    expect(context.characterArcs[0].characterId).toBe(char1.id);
    expect(context.characterArcs[0].archetype).toBe('hero');

    expect(context.activeConflicts).toBeDefined();
    expect(context.activeConflicts.length).toBe(1);
    expect(context.activeConflicts[0].type).toBe('interpersonal');

    // Verify epistemic data included
    expect(context.epistemicStates).toBeDefined();
    expect(context.epistemicStates[char1.id]).toBeDefined();

    // Supply: Context packet ready for AI
    expect(context.ready).toBe(true);
    expect(context.missingData).toEqual([]);
  });

  test('E2E: QACS with 10-character complex scene', async () => {
    // ... similar setup with 10 characters, multiple conflicts, themes, etc.
    // Verify orchestrator assembles complete context in <1s
  });

  test('E2E: QACS with dramatic irony (reader vs character knowledge)', async () => {
    // ... setup scene where reader knows more than character
    // Verify dramatic irony detected and included in context
  });

  test('E2E: QACS with causality chain traversal', async () => {
    // ... create chain of causally linked events
    // Verify context includes causal history with depth limiting
  });
});
```

**Verify complete workflow:**
- Data creation succeeds
- Orchestrator assembles context
- Context packet includes all required fields
- Performance meets targets (<1s for 10-character scene)
  </action>
  <verify>npm test tests/e2e/qacs-workflow.test.js</verify>
  <done>QACS workflow tests pass, verifying end-to-end integration</done>
</task>

<task type="auto">
  <name>Task 3: Create storage benchmarks for 10-book series</name>
  <files>tests/performance/storage.bench.js</files>
  <action>
Create storage benchmarks verifying <50MB for 10-book series:

**Test scenario:**
Simulate 10-book series with full logic layer:
- 10 books × 50 chapters × 10 scenes = 5000 events
- 100 characters across series
- 200 conflicts
- 150 character arcs
- 300 causality chains
- 100 themes
- 500 setup/payoffs
- 50 world rules
- 10,000 knowledge states
- 5,000 asset states (snapshots + deltas)

**Implementation:**
```javascript
const Database = require('better-sqlite3');
const fs = require('fs');
const path = require('path');
const createAPI = require('../../db/api-functions');

async function benchmarkStorage() {
  const testDbPath = path.join(__dirname, 'storage-bench-test.db');

  // Clean up if exists
  if (fs.existsSync(testDbPath)) {
    fs.unlinkSync(testDbPath);
  }

  // Create database
  const db = new Database(testDbPath);
  db.pragma('foreign_keys = ON');

  // Load schema
  const schemaPath = path.join(__dirname, '../../db/schema.sql');
  const schema = fs.readFileSync(schemaPath, 'utf8');
  db.exec(schema);

  const api = createAPI(db);

  console.log('Populating 10-book series...');

  // Create project
  const project = api.projects.createProject('Epic Series');

  // Create 10 books
  for (let bookNum = 1; bookNum <= 10; bookNum++) {
    const fiction = api.fictions.createFiction(
      project.projectId,
      `Book ${bookNum}`
    );

    console.log(`  Creating Book ${bookNum}...`);

    // Create 10 characters per book (100 total, some shared across books)
    const characters = [];
    for (let c = 0; c < 10; c++) {
      const char = api.entities.createEntity({
        fictionId: fiction.fictionId,
        name: `Character ${bookNum}-${c}`,
        type: 'character'
      });
      characters.push(char);

      // Create character arc
      api.characterArcs.createArc(
        fiction.fictionId,
        char.id,
        ['hero', 'mentor', 'trickster'][c % 3],
        'Lie belief',
        'Truth belief',
        'External want',
        'Internal need',
        'setup'
      );
    }

    // Create 500 events (5000 total across 10 books)
    const events = [];
    for (let e = 0; e < 500; e++) {
      const event = api.entities.createEntity({
        fictionId: fiction.fictionId,
        name: `Event ${bookNum}-${e}`,
        type: 'event',
        timestamp: new Date(2025, 0, 1, 0, 0, e).toISOString()
      });
      events.push(event);

      // Add epistemic states (2 per event = 10,000 total)
      if (e % 5 === 0 && characters.length >= 2) {
        api.epistemic.createKnowledgeState(
          fiction.fictionId,
          characters[0].id,
          event.id,
          `fact_${e}`,
          true
        );

        api.epistemic.createKnowledgeState(
          fiction.fictionId,
          characters[1].id,
          event.id,
          `fact_${e}`,
          true
        );
      }
    }

    // Create 20 conflicts per book (200 total)
    for (let conf = 0; conf < 20; conf++) {
      api.storyConflicts.createConflict(
        fiction.fictionId,
        ['internal', 'interpersonal', 'societal'][conf % 3],
        characters[0].id,
        characters[1]?.id || 'external',
        'Success stakes',
        'Failure stakes',
        'latent'
      );
    }

    // Create 30 causality chains per book (300 total)
    for (let chain = 0; chain < 30 && events.length >= 2; chain++) {
      api.causalityChains.createChain(
        fiction.fictionId,
        events[chain].id,
        events[chain + 1].id,
        'direct_cause',
        7,
        'Causal explanation'
      );
    }

    // Create 10 themes per book (100 total)
    for (let theme = 0; theme < 10; theme++) {
      api.thematicElements.createElement(
        fiction.fictionId,
        `Theme statement ${theme}`,
        characters[0].id,
        `Theme question ${theme}`,
        JSON.stringify(['manifestation1', 'manifestation2'])
      );
    }

    // Create 50 setup/payoffs per book (500 total)
    for (let setup = 0; setup < 50 && events.length >= 20; setup++) {
      api.setupPayoffs.createSetup(
        fiction.fictionId,
        events[setup].id,
        events[setup + 10]?.id || null,
        `Setup description ${setup}`,
        'planted',
        Math.floor(setup / 10),
        null
      );
    }

    // Create 5 world rules per book (50 total)
    for (let rule = 0; rule < 5; rule++) {
      api.worldRules.createRule(
        fiction.fictionId,
        ['physics', 'magic', 'social'][rule % 3],
        `Rule statement ${rule}`,
        'No exceptions',
        'strict'
      );
    }
  }

  // Close database and measure
  db.close();

  const stats = fs.statSync(testDbPath);
  const sizeMB = stats.size / (1024 * 1024);

  // Clean up
  fs.unlinkSync(testDbPath);

  return {
    category: 'Storage Efficiency',
    target_mb: 50,
    actual_mb: sizeMB,
    passed: sizeMB < 50,
    details: {
      books: 10,
      events: 5000,
      characters: 100,
      conflicts: 200,
      arcs: 100,
      causality_chains: 300,
      themes: 100,
      setup_payoffs: 500,
      world_rules: 50,
      knowledge_states: 10000,
      total_size_bytes: stats.size,
      total_size_mb: sizeMB.toFixed(2)
    }
  };
}

module.exports = benchmarkStorage;

// Run standalone
if (require.main === module) {
  benchmarkStorage().then(result => {
    console.log('Storage Benchmark Results:');
    console.log(JSON.stringify(result, null, 2));
    if (!result.passed) {
      console.error('❌ Storage target not met!');
      process.exit(1);
    }
  });
}
```

**Verification:**
- Database file size <50MB after full population
- Measure size with `fs.statSync().size`
- Report breakdown by table (optional deep dive)
  </action>
  <verify>node tests/performance/storage.bench.js</verify>
  <done>Storage benchmark passes with <50MB for 10-book series</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Run api-routes-comprehensive tests and verify all pass
- [ ] Run qacs-workflow E2E tests and verify QACS succeeds
- [ ] Run storage benchmark and verify <50MB
- [ ] Verify server responds correctly to all tested routes
- [ ] Check that validation endpoints work (depends on 13-01)
</verification>

<success_criteria>
- All API route integration tests pass (50+ tests)
- QACS workflow E2E tests pass (4+ scenarios)
- Storage benchmark passes (<50MB for 10-book series)
- No test failures or errors
- Complete integration coverage for all API routes
</success_criteria>

<output>
After completion, create `.planning/phases/13-validation-testing/13-03-SUMMARY.md`
</output>
