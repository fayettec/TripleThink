---
phase: 13-validation-testing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - api/services/validator.js
  - api/routes/validation.js
  - schema/validation-rules.md
autonomous: true

must_haves:
  truths:
    - "Validation service returns comprehensive report with 100+ rule results"
    - "All 8 validation categories execute (epistemic, causality, arcs, conflicts, setup/payoffs, world rules, narrative, performance)"
    - "Validation GUI screen displays results organized by category tabs"
  artifacts:
    - path: "api/services/validator.js"
      provides: "Validation service with 100+ rules across 8 categories"
      min_lines: 800
      exports: ["TripleThinkValidator", "validateDatabase"]
    - path: "api/routes/validation.js"
      provides: "Validation API endpoints"
      min_lines: 80
      exports: ["router"]
    - path: "schema/validation-rules.md"
      provides: "Documentation of all validation rules"
      min_lines: 500
  key_links:
    - from: "api/routes/validation.js"
      to: "api/services/validator.js"
      via: "imports TripleThinkValidator class"
      pattern: "require.*validator"
    - from: "gui/js/screens/validation.js"
      to: "/api/validation"
      via: "fetches validation results"
      pattern: "api.*validation"
---

<objective>
Create comprehensive validation service with 100+ rules across 8 categories.

Purpose: Enable database consistency verification through automated rule checking. Validation catches epistemic contradictions, temporal inconsistencies, broken references, and logic layer errors before they propagate.

Output: Operational validation service integrated with API and documented validation rules.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Codebase context
@.planning/codebase/TESTING.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/CONVENTIONS.md

# Prior work
@.planning/phases/06-logic-layer-integration/06-03-SUMMARY.md

# Existing files to enhance
@api/routes/validation.js
@gui/js/screens/validation.js

# Database schema for validation rules
@db/schema.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create validation service with 100+ rules</name>
  <files>api/services/validator.js</files>
  <action>
Create TripleThinkValidator class with 8 validation categories:

**1. Referential Integrity (10 rules):**
- RI-1: Entity IDs match type prefixes (evt-, char-, obj-, loc-, sys-)
- RI-2: Foreign keys reference existing entities
- RI-3: Metadata references valid entities
- RI-4: Fiction references existing projects
- RI-5: Event references valid fiction
- RI-6: Knowledge state references existing characters
- RI-7: Asset references existing entities
- RI-8: Causality chains reference existing events
- RI-9: Character arcs reference existing characters
- RI-10: Setup/payoffs reference existing events

**2. Temporal Consistency (12 rules):**
- TC-1: Event timestamps are valid ISO8601 format
- TC-2: Events within fiction are chronologically ordered by sequence_index
- TC-3: Knowledge state timestamps match or follow event timestamps
- TC-4: Asset state changes reference existing events
- TC-5: No duplicate sequence_index within same fiction
- TC-6: Event moments ordered within parent event
- TC-7: Setup planted_chapter â‰¤ fired_chapter
- TC-8: Timestamps parseable and not in future
- TC-9: Character arc phase transitions sequential
- TC-10: Conflict status transitions valid
- TC-11: Event moments timestamp_offset within event duration
- TC-12: Snapshot anchors every 10 events verified

**3. Epistemic Consistency (7 rules):**
- EC-1: Characters cannot know facts before they're revealed
- EC-2: False beliefs have corresponding true facts
- EC-3: Knowledge state cumulative (no knowledge loss)
- EC-4: Dramatic irony properly tracked (reader knows more)
- EC-5: Knowledge reveals reference existing facts
- EC-6: Fact categories match entity types
- EC-7: No orphaned knowledge states

**4. Fiction System (7 rules):**
- FS-1: Every fiction belongs to project
- FS-2: Fiction names unique within project
- FS-3: Fiction has at least one entity
- FS-4: Entity types valid (event/character/object/location/system)
- FS-5: Metadata optional but if exists, valid JSON
- FS-6: Fiction IDs follow convention (fic-*)
- FS-7: Project IDs follow convention (proj-*)

**5. Narrative Consistency (8 rules):**
- NC-1: Scenes have valid chapter assignments
- NC-2: Scene present_entity_ids reference existing entities
- NC-3: Scene active_conflict_ids reference existing conflicts
- NC-4: Scene active_theme_ids reference existing themes
- NC-5: Chapter numbering sequential
- NC-6: Scene numbering sequential within chapter
- NC-7: Narrative timeline coherent
- NC-8: Split/merge operations maintain referential integrity

**6. Logic Layer (15 rules):**
- LL-1: Causality chain strength 1-10
- LL-2: Causality chain type valid (direct_cause, enabling_condition, motivation, psychological_trigger)
- LL-3: Character arc phase valid (13-beat structure)
- LL-4: Character arc archetype valid
- LL-5: Conflict type valid (internal, interpersonal, societal, environmental)
- LL-6: Conflict status valid (latent, active, escalating, climactic, resolved)
- LL-7: Setup status valid (planted, referenced, fired)
- LL-8: World rule category valid (physics, magic, social, economic, political)
- LL-9: World rule enforcement_level valid (strict, flexible, guideline)
- LL-10: Theme manifestations valid JSON array
- LL-11: Motif instances link to existing entities
- LL-12: Setup payoff_event_id follows setup_event_id temporally
- LL-13: Causality chains no circular dependencies
- LL-14: Arc progression monotonic (phases don't regress)
- LL-15: Conflict protagonist_id immutable

**7. State Integrity (10 rules):**
- SI-1: Asset snapshots reference valid assets
- SI-2: Asset deltas form valid chain
- SI-3: Delta chain length reasonable (<100 from snapshot)
- SI-4: Snapshot every 10 events exists
- SI-5: State reconstruction produces valid JSON
- SI-6: No orphaned deltas
- SI-7: No orphaned snapshots
- SI-8: State changes reference events
- SI-9: Asset state at_event_id valid
- SI-10: Snapshot timestamps align with anchor events

**8. Cross-Entity (10 rules):**
- XE-1: Relationship both_entity_ids exist
- XE-2: Relationship types valid (trust, fear, respect, power)
- XE-3: Relationship values in range (0-100)
- XE-4: No duplicate relationships (same entities + type)
- XE-5: Entity metadata consistency
- XE-6: Causality chains connect existing events
- XE-7: Character arcs cover all present characters
- XE-8: Conflicts reference valid antagonists
- XE-9: Themes reference valid symbols
- XE-10: Motifs cluster coherently

**Implementation pattern:**
```javascript
class TripleThinkValidator {
  constructor(db) {
    this.db = db;
    this.rules = this.initializeRules();
  }

  initializeRules() {
    return {
      referential_integrity: [
        { id: 'RI-1', name: 'Entity ID Prefix Match', severity: 'critical', check: (db) => { /* ... */ } },
        // ... 9 more
      ],
      temporal_consistency: [ /* 12 rules */ ],
      epistemic_consistency: [ /* 7 rules */ ],
      fiction_system: [ /* 7 rules */ ],
      narrative_consistency: [ /* 8 rules */ ],
      logic_layer: [ /* 15 rules */ ],
      state_integrity: [ /* 10 rules */ ],
      cross_entity: [ /* 10 rules */ ]
    };
  }

  async validateDatabase() {
    const report = {
      timestamp: new Date().toISOString(),
      summary: { total_rules: 0, passed: 0, failed: 0, warnings: 0 },
      categories: {},
      errors: [],
      warnings: []
    };

    for (const [category, rules] of Object.entries(this.rules)) {
      const categoryResults = await this.runCategoryRules(category, rules);
      report.categories[category] = categoryResults;
      // Aggregate stats
    }

    return report;
  }

  async runCategoryRules(category, rules) { /* ... */ }
}

module.exports = TripleThinkValidator;
```

Each rule returns: `{ passed: boolean, errors: [], warnings: [] }`
  </action>
  <verify>node -e "const V = require('./api/services/validator.js'); console.log(Object.keys(new V({}).rules).length)"</verify>
  <done>Validator service exists with 8 categories and 100+ rules total</done>
</task>

<task type="auto">
  <name>Task 2: Integrate validation service into API route</name>
  <files>api/routes/validation.js</files>
  <action>
Replace stub implementation with full validation endpoints:

**Endpoints:**
- GET `/api/validation` - Run full validation and return comprehensive report
- GET `/api/validation/summary` - Return summary stats only
- GET `/api/validation/errors` - Return only errors
- GET `/api/validation/warnings` - Return only warnings
- GET `/api/validation/category/:category` - Return results for specific category
- GET `/api/validation/categories` - List all validation categories
- GET `/api/validation/health` - Quick health check (run critical rules only)
- POST `/api/validation/run` - Trigger validation and return job status

**Implementation:**
```javascript
const TripleThinkValidator = require('../services/validator');

module.exports = (db) => {
  const router = express.Router();

  router.get('/', async (req, res) => {
    try {
      const validator = new TripleThinkValidator(db);
      const report = await validator.validateDatabase();
      res.json(report);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  });

  router.get('/summary', async (req, res) => { /* ... */ });
  router.get('/errors', async (req, res) => { /* ... */ });
  router.get('/warnings', async (req, res) => { /* ... */ });
  router.get('/category/:category', async (req, res) => { /* ... */ });
  router.get('/categories', async (req, res) => { /* ... */ });
  router.get('/health', async (req, res) => { /* ... */ });
  router.post('/run', async (req, res) => { /* ... */ });

  return router;
};
```

Verify route is already registered in server.js (it is: line already exists)
  </action>
  <verify>curl http://localhost:3000/api/validation/categories | jq '.categories | length' # Should return 8</verify>
  <done>Validation API returns full reports with 8 categories</done>
</task>

<task type="auto">
  <name>Task 3: Document validation rules</name>
  <files>schema/validation-rules.md</files>
  <action>
Create comprehensive documentation of all 100+ validation rules:

**Structure:**
```markdown
# TripleThink Validation Rules

## Overview
100+ validation rules across 8 categories ensuring database consistency.

## Rule Categories

### 1. Referential Integrity (RI-1 to RI-10)
Critical rules ensuring foreign key consistency.

**RI-1: Entity ID Prefix Match**
- **Severity:** Critical
- **Description:** Entity IDs must match their type prefix
- **Check:** Events start with evt-, characters with char-, etc.
- **Fix:** Correct entity ID or type field

[... document all 10 RI rules ...]

### 2. Temporal Consistency (TC-1 to TC-12)
[... document all 12 TC rules ...]

### 3. Epistemic Consistency (EC-1 to EC-7)
[... document all 7 EC rules ...]

### 4. Fiction System (FS-1 to FS-7)
[... document all 7 FS rules ...]

### 5. Narrative Consistency (NC-1 to NC-8)
[... document all 8 NC rules ...]

### 6. Logic Layer (LL-1 to LL-15)
[... document all 15 LL rules ...]

### 7. State Integrity (SI-1 to SI-10)
[... document all 10 SI rules ...]

### 8. Cross-Entity (XE-1 to XE-10)
[... document all 10 XE rules ...]

## Severity Levels
- **Critical:** Database corruption, must fix immediately
- **Error:** Logical inconsistency, should fix before production
- **Warning:** Best practice violation, fix when convenient

## Running Validation
```bash
curl http://localhost:3000/api/validation
curl http://localhost:3000/api/validation/category/epistemic_consistency
```
```

Provide enough detail for developers to understand what each rule checks and how to fix violations.
  </action>
  <verify>wc -l schema/validation-rules.md # Should be >500 lines</verify>
  <done>Validation rules documented with descriptions, severity, and fix guidance</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Run validation service and verify 8 categories execute
- [ ] Test all 8 API endpoints return valid responses
- [ ] Verify validation-rules.md has >500 lines with all 100+ rules documented
- [ ] Check that validation GUI screen can fetch and display results
- [ ] Verify no errors in validator service initialization
</verification>

<success_criteria>
- Validation service exists with 100+ rules across 8 categories
- All API endpoints operational and returning correct data
- Validation rules comprehensively documented
- No errors when importing or instantiating validator
- GUI validation screen compatible with API response format
</success_criteria>

<output>
After completion, create `.planning/phases/13-validation-testing/13-01-SUMMARY.md`
</output>
