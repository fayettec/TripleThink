---
phase: 01-foundation-enhancement
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - api/routes/moments.js
  - api/server.js
  - tests/integration/event-moments.test.js
autonomous: true

must_haves:
  truths:
    - "API endpoint POST /api/moments creates moments"
    - "API endpoint GET /api/moments/:eventUuid returns moments for event"
    - "API endpoint PUT /api/moments/:momentUuid updates moments"
    - "API endpoint DELETE /api/moments/:momentUuid deletes moments"
    - "Moments returned via API are ordered by sequence_index"
    - "Integration tests verify all CRUD operations and sequencing"
  artifacts:
    - path: "api/routes/moments.js"
      provides: "REST endpoints for moments"
      min_lines: 80
      exports: ["router function"]
    - path: "tests/integration/event-moments.test.js"
      provides: "Integration tests for moments API"
      min_lines: 100
      contains: "describe('EVENT_MOMENTS API"
  key_links:
    - from: "api/routes/moments.js"
      to: "db/modules/event-moments.js"
      via: "route handler calls module functions"
      pattern: "eventMoments\\.(create|get|update|delete)"
    - from: "api/server.js"
      to: "api/routes/moments.js"
      via: "route registration"
      pattern: "app\\.use\\(\\'.*moments"
    - from: "tests/integration/event-moments.test.js"
      to: "api/routes/moments.js"
      via: "HTTP requests in tests"
      pattern: "request\\(.*\\)\\.post\\(.*moments"
---

<objective>
Expose EVENT_MOMENTS functionality via REST API and verify with integration tests.

Purpose: Makes granular beat tracking accessible to GUI and future AI agents. Validates sequencing behavior and CRUD operations end-to-end.

Output: Working API endpoints with comprehensive test coverage.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Codebase context
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/TESTING.md

# Prior plan output
@.planning/phases/01-foundation-enhancement/01-01-SUMMARY.md

# Existing routes for pattern reference
@api/routes/epistemic.js
@api/routes/state.js

# Server configuration
@api/server.js

# Existing integration tests for pattern reference
@tests/integration/phase5-api-integration.test.js

# Database module created in Plan 01
@db/modules/event-moments.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create moments API route</name>
  <files>api/routes/moments.js</files>
  <action>
Create `api/routes/moments.js` following existing route patterns (`epistemic.js`, `state.js`).

**Route structure:**
```javascript
// Moments API Routes
// REST endpoints for EVENT_MOMENTS table
// Provides granular beat tracking within events

const express = require('express');
const eventMoments = require('../../db/modules/event-moments');

module.exports = (db) => {
  const router = express.Router();
  const moments = eventMoments(db);

  // POST /api/moments - Create new moment
  router.post('/', (req, res, next) => {
    try {
      const { event_uuid, sequence_index, beat_description, timestamp_offset } = req.body;

      // Validate required fields
      if (!event_uuid || sequence_index === undefined || !beat_description) {
        return res.status(400).json({ error: 'Missing required fields: event_uuid, sequence_index, beat_description' });
      }

      const moment = moments.createMoment(event_uuid, sequence_index, beat_description, timestamp_offset);
      res.status(201).json(moment);
    } catch (err) {
      next(err);
    }
  });

  // GET /api/moments/:eventUuid - Get all moments for an event
  router.get('/:eventUuid', (req, res, next) => {
    try {
      const { eventUuid } = req.params;
      const momentsList = moments.getMomentsByEvent(eventUuid);
      res.json(momentsList);
    } catch (err) {
      next(err);
    }
  });

  // PUT /api/moments/:momentUuid - Update a moment
  router.put('/:momentUuid', (req, res, next) => {
    try {
      const { momentUuid } = req.params;
      const updates = req.body;

      const updated = moments.updateMoment(momentUuid, updates);
      if (!updated) {
        return res.status(404).json({ error: 'Moment not found' });
      }

      res.json(updated);
    } catch (err) {
      next(err);
    }
  });

  // DELETE /api/moments/:momentUuid - Delete a moment
  router.delete('/:momentUuid', (req, res, next) => {
    try {
      const { momentUuid } = req.params;
      const deleted = moments.deleteMoment(momentUuid);

      if (!deleted) {
        return res.status(404).json({ error: 'Moment not found' });
      }

      res.status(204).send();
    } catch (err) {
      next(err);
    }
  });

  return router;
};
```

**Key patterns:**
- Export function accepting `db` parameter
- Use Express router
- Wrap handlers in try-catch, call `next(err)` for error middleware
- Return 201 for create, 200 for update, 204 for delete, 400 for validation errors, 404 for not found
- Destructure request params/body for clarity
- Follow kebab-case file naming convention
  </action>
  <verify>
```bash
# Verify route file has no syntax errors
node -e "require('./api/routes/moments')"

# Check exports function
node -e "const route = require('./api/routes/moments'); console.log(typeof route)"
```
  </verify>
  <done>
- Route file exists at `api/routes/moments.js`
- Exports function that returns Express router
- Implements 4 endpoints: POST /, GET /:eventUuid, PUT /:momentUuid, DELETE /:momentUuid
- Includes input validation
- Uses proper HTTP status codes
- Follows existing route patterns
  </done>
</task>

<task type="auto">
  <name>Task 2: Register moments route in server.js</name>
  <files>api/server.js</files>
  <action>
Register moments route in `api/server.js` following existing pattern.

**Changes:**
1. Add import after existing route imports:
```javascript
const momentsRoutes = require('./routes/moments');
```

2. Add route registration after existing routes (before health check endpoint):
```javascript
app.use('/api/moments', momentsRoutes(db));
```

**Pattern to follow:**
- Import placed with other route imports (around line 26-28)
- Registration placed with other registrations (around line 31-33)
- Maintain alphabetical order if routes are ordered
- Use consistent spacing and formatting

Do NOT modify any other parts of server.js - only add these two lines in appropriate locations.
  </action>
  <verify>
```bash
# Start server and verify route registered
node api/server.js &
SERVER_PID=$!
sleep 2

# Test health check still works
curl -s http://localhost:3000/health | grep "ok"

# Test moments endpoint exists (should return 400 or empty array, not 404)
curl -s http://localhost:3000/api/moments/test-event || echo "Endpoint exists"

# Cleanup
kill $SERVER_PID
```
  </verify>
  <done>
- server.js updated with moments route import and registration
- Server starts without errors
- /api/moments endpoints accessible (not 404)
- Existing routes still functional
- No syntax errors introduced
  </done>
</task>

<task type="auto">
  <name>Task 3: Create integration tests</name>
  <files>tests/integration/event-moments.test.js</files>
  <action>
Create comprehensive integration tests following existing patterns in `phase5-api-integration.test.js`.

**Test structure:**
```javascript
const request = require('supertest');
const Database = require('better-sqlite3');
const app = require('../../api/server');

describe('EVENT_MOMENTS API Integration Tests', () => {
  let db;
  const testEventUuid = 'test-event-integration-001';

  beforeAll(() => {
    // Initialize test database
    db = new Database('db/triplethink.db');
    // Clean up any existing test data
    db.prepare('DELETE FROM event_moments WHERE event_uuid = ?').run(testEventUuid);
  });

  afterAll(() => {
    // Clean up test data
    db.prepare('DELETE FROM event_moments WHERE event_uuid = ?').run(testEventUuid);
    db.close();
  });

  describe('POST /api/moments', () => {
    test('creates moment with all fields', async () => {
      const response = await request(app)
        .post('/api/moments')
        .send({
          event_uuid: testEventUuid,
          sequence_index: 1,
          beat_description: 'Character enters scene',
          timestamp_offset: 0
        })
        .expect(201);

      expect(response.body).toHaveProperty('moment_uuid');
      expect(response.body.event_uuid).toBe(testEventUuid);
      expect(response.body.sequence_index).toBe(1);
      expect(response.body.beat_description).toBe('Character enters scene');
    });

    test('creates moment without optional timestamp_offset', async () => {
      const response = await request(app)
        .post('/api/moments')
        .send({
          event_uuid: testEventUuid,
          sequence_index: 2,
          beat_description: 'Character speaks'
        })
        .expect(201);

      expect(response.body).toHaveProperty('moment_uuid');
      expect(response.body.timestamp_offset).toBeNull();
    });

    test('rejects missing required fields', async () => {
      await request(app)
        .post('/api/moments')
        .send({
          event_uuid: testEventUuid
          // Missing sequence_index and beat_description
        })
        .expect(400);
    });
  });

  describe('GET /api/moments/:eventUuid', () => {
    test('returns moments in sequence_index order', async () => {
      // Create moments out of order
      await request(app).post('/api/moments').send({
        event_uuid: testEventUuid,
        sequence_index: 3,
        beat_description: 'Third beat'
      });

      await request(app).post('/api/moments').send({
        event_uuid: testEventUuid,
        sequence_index: 1,
        beat_description: 'First beat'
      });

      await request(app).post('/api/moments').send({
        event_uuid: testEventUuid,
        sequence_index: 2,
        beat_description: 'Second beat'
      });

      const response = await request(app)
        .get(`/api/moments/${testEventUuid}`)
        .expect(200);

      expect(response.body).toHaveLength(3);
      expect(response.body[0].sequence_index).toBe(1);
      expect(response.body[1].sequence_index).toBe(2);
      expect(response.body[2].sequence_index).toBe(3);
    });

    test('returns empty array for non-existent event', async () => {
      const response = await request(app)
        .get('/api/moments/non-existent-event')
        .expect(200);

      expect(response.body).toHaveLength(0);
    });
  });

  describe('PUT /api/moments/:momentUuid', () => {
    test('updates beat_description', async () => {
      // Create moment
      const createResponse = await request(app)
        .post('/api/moments')
        .send({
          event_uuid: testEventUuid,
          sequence_index: 10,
          beat_description: 'Original description'
        });

      const momentUuid = createResponse.body.moment_uuid;

      // Update moment
      const updateResponse = await request(app)
        .put(`/api/moments/${momentUuid}`)
        .send({ beat_description: 'Updated description' })
        .expect(200);

      expect(updateResponse.body.beat_description).toBe('Updated description');
      expect(updateResponse.body.sequence_index).toBe(10); // Unchanged
    });

    test('returns 404 for non-existent moment', async () => {
      await request(app)
        .put('/api/moments/non-existent-uuid')
        .send({ beat_description: 'Test' })
        .expect(404);
    });
  });

  describe('DELETE /api/moments/:momentUuid', () => {
    test('deletes moment successfully', async () => {
      // Create moment
      const createResponse = await request(app)
        .post('/api/moments')
        .send({
          event_uuid: testEventUuid,
          sequence_index: 99,
          beat_description: 'To be deleted'
        });

      const momentUuid = createResponse.body.moment_uuid;

      // Delete moment
      await request(app)
        .delete(`/api/moments/${momentUuid}`)
        .expect(204);

      // Verify deletion
      const getResponse = await request(app)
        .get(`/api/moments/${testEventUuid}`)
        .expect(200);

      const deleted = getResponse.body.find(m => m.moment_uuid === momentUuid);
      expect(deleted).toBeUndefined();
    });

    test('returns 404 for non-existent moment', async () => {
      await request(app)
        .delete('/api/moments/non-existent-uuid')
        .expect(404);
    });
  });
});
```

**Key test patterns:**
- Use Jest framework with `describe` and `test` blocks
- Use `supertest` for HTTP testing
- Clean up test data in `beforeAll` and `afterAll`
- Test happy paths and error cases
- Verify sequencing behavior explicitly
- Test optional fields (timestamp_offset)
- Use descriptive test names
- Verify HTTP status codes
- Check response body structure
  </action>
  <verify>
```bash
# Run integration tests
npm test -- tests/integration/event-moments.test.js

# Check for passing tests (should see all green)
npm test -- tests/integration/event-moments.test.js 2>&1 | grep "PASS"

# Verify test coverage includes all CRUD operations
npm test -- tests/integration/event-moments.test.js 2>&1 | grep -E "(POST|GET|PUT|DELETE)"
```
  </verify>
  <done>
- Integration test file exists at `tests/integration/event-moments.test.js`
- Tests cover all 4 endpoints (POST, GET, PUT, DELETE)
- Tests verify sequencing behavior (moments returned in order)
- Tests include error cases (missing fields, not found)
- All tests pass
- Test cleanup prevents data pollution
- Follows existing test patterns from phase5-api-integration.test.js
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm test -- tests/integration/event-moments.test.js` passes all tests
- [ ] API endpoints accessible: POST /api/moments, GET /api/moments/:eventUuid, PUT /api/moments/:momentUuid, DELETE /api/moments/:momentUuid
- [ ] Manual API test confirms sequencing:
  ```bash
  # Create moments out of order
  curl -X POST http://localhost:3000/api/moments -H "Content-Type: application/json" -d '{"event_uuid":"manual-test","sequence_index":3,"beat_description":"Third"}'
  curl -X POST http://localhost:3000/api/moments -H "Content-Type: application/json" -d '{"event_uuid":"manual-test","sequence_index":1,"beat_description":"First"}'
  curl -X POST http://localhost:3000/api/moments -H "Content-Type: application/json" -d '{"event_uuid":"manual-test","sequence_index":2,"beat_description":"Second"}'

  # Verify order
  curl http://localhost:3000/api/moments/manual-test | jq '.[].sequence_index'
  # Should output: 1, 2, 3
  ```
- [ ] No errors or warnings in test output
- [ ] All requirements FOUND-01 through FOUND-05 satisfied
</verification>

<success_criteria>
- All tasks completed
- API endpoints operational and registered in server.js
- Integration tests pass with 100% success rate
- Manual API testing confirms sequencing behavior
- Phase 1 complete: EVENT_MOMENTS fully implemented and tested
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-enhancement/01-02-SUMMARY.md`
</output>
